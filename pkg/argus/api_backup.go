/*
STACKIT Argus API

API endpoints for Argus on STACKIT

API version: v1
Contact: stackit-argus@mail.schwarz
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package argus

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// BackupApiService BackupApi service
type BackupApiService service

type ApiV1InstancesBackupRestoresCreateRequest struct {
	ctx context.Context
	ApiService *BackupApiService
	backupDate string
	instanceId string
	authorization *string
	restoreTarget *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesBackupRestoresCreateRequest) Authorization(authorization string) ApiV1InstancesBackupRestoresCreateRequest {
	r.authorization = &authorization
	return r
}

// List of restore targets
func (r ApiV1InstancesBackupRestoresCreateRequest) RestoreTarget(restoreTarget string) ApiV1InstancesBackupRestoresCreateRequest {
	r.restoreTarget = &restoreTarget
	return r
}

func (r ApiV1InstancesBackupRestoresCreateRequest) Execute() (*Message, *http.Response, error) {
	return r.ApiService.V1InstancesBackupRestoresCreateExecute(r)
}

/*
V1InstancesBackupRestoresCreate Method for V1InstancesBackupRestoresCreate

Restore backup.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param backupDate
 @param instanceId
 @return ApiV1InstancesBackupRestoresCreateRequest
*/
func (a *BackupApiService) V1InstancesBackupRestoresCreate(ctx context.Context, backupDate string, instanceId string) ApiV1InstancesBackupRestoresCreateRequest {
	return ApiV1InstancesBackupRestoresCreateRequest{
		ApiService: a,
		ctx: ctx,
		backupDate: backupDate,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return Message
func (a *BackupApiService) V1InstancesBackupRestoresCreateExecute(r ApiV1InstancesBackupRestoresCreateRequest) (*Message, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Message
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BackupApiService.V1InstancesBackupRestoresCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/backup-restores/{backupDate}"
	localVarPath = strings.Replace(localVarPath, "{"+"backupDate"+"}", url.PathEscape(parameterToString(r.backupDate, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.restoreTarget == nil {
		return localVarReturnValue, nil, reportError("restoreTarget is required and must be specified")
	}

	localVarQueryParams.Add("restoreTarget", parameterToString(*r.restoreTarget, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesBackupRetentionsListRequest struct {
	ctx context.Context
	ApiService *BackupApiService
	instanceId string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesBackupRetentionsListRequest) Authorization(authorization string) ApiV1InstancesBackupRetentionsListRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesBackupRetentionsListRequest) Execute() (*BackupRetentionResponse, *http.Response, error) {
	return r.ApiService.V1InstancesBackupRetentionsListExecute(r)
}

/*
V1InstancesBackupRetentionsList Method for V1InstancesBackupRetentionsList

Get backup retention.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @return ApiV1InstancesBackupRetentionsListRequest
*/
func (a *BackupApiService) V1InstancesBackupRetentionsList(ctx context.Context, instanceId string) ApiV1InstancesBackupRetentionsListRequest {
	return ApiV1InstancesBackupRetentionsListRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return BackupRetentionResponse
func (a *BackupApiService) V1InstancesBackupRetentionsListExecute(r ApiV1InstancesBackupRetentionsListRequest) (*BackupRetentionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BackupRetentionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BackupApiService.V1InstancesBackupRetentionsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/backup-retentions"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesBackupRetentionsUpdateRequest struct {
	ctx context.Context
	ApiService *BackupApiService
	instanceId string
	authorization *string
	data *V1InstancesBackupRetentionsUpdateRequest
	backupTarget *[]string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesBackupRetentionsUpdateRequest) Authorization(authorization string) ApiV1InstancesBackupRetentionsUpdateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesBackupRetentionsUpdateRequest) Data(data V1InstancesBackupRetentionsUpdateRequest) ApiV1InstancesBackupRetentionsUpdateRequest {
	r.data = &data
	return r
}

// List of backup targets
func (r ApiV1InstancesBackupRetentionsUpdateRequest) BackupTarget(backupTarget []string) ApiV1InstancesBackupRetentionsUpdateRequest {
	r.backupTarget = &backupTarget
	return r
}

func (r ApiV1InstancesBackupRetentionsUpdateRequest) Execute() (*Message, *http.Response, error) {
	return r.ApiService.V1InstancesBackupRetentionsUpdateExecute(r)
}

/*
V1InstancesBackupRetentionsUpdate Method for V1InstancesBackupRetentionsUpdate

Update backup retention.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @return ApiV1InstancesBackupRetentionsUpdateRequest
*/
func (a *BackupApiService) V1InstancesBackupRetentionsUpdate(ctx context.Context, instanceId string) ApiV1InstancesBackupRetentionsUpdateRequest {
	return ApiV1InstancesBackupRetentionsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return Message
func (a *BackupApiService) V1InstancesBackupRetentionsUpdateExecute(r ApiV1InstancesBackupRetentionsUpdateRequest) (*Message, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Message
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BackupApiService.V1InstancesBackupRetentionsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/backup-retentions"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	if r.backupTarget != nil {
		localVarQueryParams.Add("backupTarget", parameterToString(*r.backupTarget, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesBackupSchedulesCreateRequest struct {
	ctx context.Context
	ApiService *BackupApiService
	instanceId string
	authorization *string
	data *V1InstancesBackupSchedulesCreateRequest
	backupTarget *[]string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesBackupSchedulesCreateRequest) Authorization(authorization string) ApiV1InstancesBackupSchedulesCreateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesBackupSchedulesCreateRequest) Data(data V1InstancesBackupSchedulesCreateRequest) ApiV1InstancesBackupSchedulesCreateRequest {
	r.data = &data
	return r
}

// List of backup targets
func (r ApiV1InstancesBackupSchedulesCreateRequest) BackupTarget(backupTarget []string) ApiV1InstancesBackupSchedulesCreateRequest {
	r.backupTarget = &backupTarget
	return r
}

func (r ApiV1InstancesBackupSchedulesCreateRequest) Execute() (*BackupSchedulePostResponse, *http.Response, error) {
	return r.ApiService.V1InstancesBackupSchedulesCreateExecute(r)
}

/*
V1InstancesBackupSchedulesCreate Method for V1InstancesBackupSchedulesCreate

Create backup schedule.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @return ApiV1InstancesBackupSchedulesCreateRequest
*/
func (a *BackupApiService) V1InstancesBackupSchedulesCreate(ctx context.Context, instanceId string) ApiV1InstancesBackupSchedulesCreateRequest {
	return ApiV1InstancesBackupSchedulesCreateRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return BackupSchedulePostResponse
func (a *BackupApiService) V1InstancesBackupSchedulesCreateExecute(r ApiV1InstancesBackupSchedulesCreateRequest) (*BackupSchedulePostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BackupSchedulePostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BackupApiService.V1InstancesBackupSchedulesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/backup-schedules"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	if r.backupTarget != nil {
		localVarQueryParams.Add("backupTarget", parameterToString(*r.backupTarget, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesBackupSchedulesDeleteRequest struct {
	ctx context.Context
	ApiService *BackupApiService
	instanceId string
	scheduleId string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesBackupSchedulesDeleteRequest) Authorization(authorization string) ApiV1InstancesBackupSchedulesDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesBackupSchedulesDeleteRequest) Execute() (*Message, *http.Response, error) {
	return r.ApiService.V1InstancesBackupSchedulesDeleteExecute(r)
}

/*
V1InstancesBackupSchedulesDelete Method for V1InstancesBackupSchedulesDelete

Delete backup schedule.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @param scheduleId
 @return ApiV1InstancesBackupSchedulesDeleteRequest
*/
func (a *BackupApiService) V1InstancesBackupSchedulesDelete(ctx context.Context, instanceId string, scheduleId string) ApiV1InstancesBackupSchedulesDeleteRequest {
	return ApiV1InstancesBackupSchedulesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
		scheduleId: scheduleId,
	}
}

// Execute executes the request
//  @return Message
func (a *BackupApiService) V1InstancesBackupSchedulesDeleteExecute(r ApiV1InstancesBackupSchedulesDeleteRequest) (*Message, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Message
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BackupApiService.V1InstancesBackupSchedulesDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/backup-schedules/{scheduleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scheduleId"+"}", url.PathEscape(parameterToString(r.scheduleId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesBackupSchedulesListRequest struct {
	ctx context.Context
	ApiService *BackupApiService
	instanceId string
	authorization *string
	backupTarget *[]string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesBackupSchedulesListRequest) Authorization(authorization string) ApiV1InstancesBackupSchedulesListRequest {
	r.authorization = &authorization
	return r
}

// List of backup targets
func (r ApiV1InstancesBackupSchedulesListRequest) BackupTarget(backupTarget []string) ApiV1InstancesBackupSchedulesListRequest {
	r.backupTarget = &backupTarget
	return r
}

func (r ApiV1InstancesBackupSchedulesListRequest) Execute() (*BackupScheduleResponse, *http.Response, error) {
	return r.ApiService.V1InstancesBackupSchedulesListExecute(r)
}

/*
V1InstancesBackupSchedulesList Method for V1InstancesBackupSchedulesList

Get backup schedules.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @return ApiV1InstancesBackupSchedulesListRequest
*/
func (a *BackupApiService) V1InstancesBackupSchedulesList(ctx context.Context, instanceId string) ApiV1InstancesBackupSchedulesListRequest {
	return ApiV1InstancesBackupSchedulesListRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return BackupScheduleResponse
func (a *BackupApiService) V1InstancesBackupSchedulesListExecute(r ApiV1InstancesBackupSchedulesListRequest) (*BackupScheduleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BackupScheduleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BackupApiService.V1InstancesBackupSchedulesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/backup-schedules"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.backupTarget != nil {
		localVarQueryParams.Add("backupTarget", parameterToString(*r.backupTarget, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesBackupSchedulesUpdateRequest struct {
	ctx context.Context
	ApiService *BackupApiService
	instanceId string
	scheduleId string
	authorization *string
	data *V1InstancesBackupSchedulesCreateRequest
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesBackupSchedulesUpdateRequest) Authorization(authorization string) ApiV1InstancesBackupSchedulesUpdateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesBackupSchedulesUpdateRequest) Data(data V1InstancesBackupSchedulesCreateRequest) ApiV1InstancesBackupSchedulesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiV1InstancesBackupSchedulesUpdateRequest) Execute() (*BackupSchedulePutResponse, *http.Response, error) {
	return r.ApiService.V1InstancesBackupSchedulesUpdateExecute(r)
}

/*
V1InstancesBackupSchedulesUpdate Method for V1InstancesBackupSchedulesUpdate

Update backup schedule.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @param scheduleId
 @return ApiV1InstancesBackupSchedulesUpdateRequest
*/
func (a *BackupApiService) V1InstancesBackupSchedulesUpdate(ctx context.Context, instanceId string, scheduleId string) ApiV1InstancesBackupSchedulesUpdateRequest {
	return ApiV1InstancesBackupSchedulesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
		scheduleId: scheduleId,
	}
}

// Execute executes the request
//  @return BackupSchedulePutResponse
func (a *BackupApiService) V1InstancesBackupSchedulesUpdateExecute(r ApiV1InstancesBackupSchedulesUpdateRequest) (*BackupSchedulePutResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BackupSchedulePutResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BackupApiService.V1InstancesBackupSchedulesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/backup-schedules/{scheduleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scheduleId"+"}", url.PathEscape(parameterToString(r.scheduleId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesBackupsCreateRequest struct {
	ctx context.Context
	ApiService *BackupApiService
	instanceId string
	authorization *string
	backupTarget *[]string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesBackupsCreateRequest) Authorization(authorization string) ApiV1InstancesBackupsCreateRequest {
	r.authorization = &authorization
	return r
}

// List of backup targets
func (r ApiV1InstancesBackupsCreateRequest) BackupTarget(backupTarget []string) ApiV1InstancesBackupsCreateRequest {
	r.backupTarget = &backupTarget
	return r
}

func (r ApiV1InstancesBackupsCreateRequest) Execute() (*Message, *http.Response, error) {
	return r.ApiService.V1InstancesBackupsCreateExecute(r)
}

/*
V1InstancesBackupsCreate Method for V1InstancesBackupsCreate

Create a backup.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @return ApiV1InstancesBackupsCreateRequest
*/
func (a *BackupApiService) V1InstancesBackupsCreate(ctx context.Context, instanceId string) ApiV1InstancesBackupsCreateRequest {
	return ApiV1InstancesBackupsCreateRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return Message
func (a *BackupApiService) V1InstancesBackupsCreateExecute(r ApiV1InstancesBackupsCreateRequest) (*Message, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Message
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BackupApiService.V1InstancesBackupsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/backups"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.backupTarget != nil {
		localVarQueryParams.Add("backupTarget", parameterToString(*r.backupTarget, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesBackupsDeleteRequest struct {
	ctx context.Context
	ApiService *BackupApiService
	backupDate string
	instanceId string
	authorization *string
	backupTarget *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesBackupsDeleteRequest) Authorization(authorization string) ApiV1InstancesBackupsDeleteRequest {
	r.authorization = &authorization
	return r
}

// Backup target selector
func (r ApiV1InstancesBackupsDeleteRequest) BackupTarget(backupTarget string) ApiV1InstancesBackupsDeleteRequest {
	r.backupTarget = &backupTarget
	return r
}

func (r ApiV1InstancesBackupsDeleteRequest) Execute() (*Message, *http.Response, error) {
	return r.ApiService.V1InstancesBackupsDeleteExecute(r)
}

/*
V1InstancesBackupsDelete Method for V1InstancesBackupsDelete

Delete backup.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param backupDate
 @param instanceId
 @return ApiV1InstancesBackupsDeleteRequest
*/
func (a *BackupApiService) V1InstancesBackupsDelete(ctx context.Context, backupDate string, instanceId string) ApiV1InstancesBackupsDeleteRequest {
	return ApiV1InstancesBackupsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		backupDate: backupDate,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return Message
func (a *BackupApiService) V1InstancesBackupsDeleteExecute(r ApiV1InstancesBackupsDeleteRequest) (*Message, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Message
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BackupApiService.V1InstancesBackupsDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/backups/{backupDate}"
	localVarPath = strings.Replace(localVarPath, "{"+"backupDate"+"}", url.PathEscape(parameterToString(r.backupDate, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.backupTarget == nil {
		return localVarReturnValue, nil, reportError("backupTarget is required and must be specified")
	}

	localVarQueryParams.Add("backupTarget", parameterToString(*r.backupTarget, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesBackupsListRequest struct {
	ctx context.Context
	ApiService *BackupApiService
	instanceId string
	authorization *string
	backupTarget *[]string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesBackupsListRequest) Authorization(authorization string) ApiV1InstancesBackupsListRequest {
	r.authorization = &authorization
	return r
}

// List of backup targets
func (r ApiV1InstancesBackupsListRequest) BackupTarget(backupTarget []string) ApiV1InstancesBackupsListRequest {
	r.backupTarget = &backupTarget
	return r
}

func (r ApiV1InstancesBackupsListRequest) Execute() (*BackupResponse, *http.Response, error) {
	return r.ApiService.V1InstancesBackupsListExecute(r)
}

/*
V1InstancesBackupsList Method for V1InstancesBackupsList

Get backups.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @return ApiV1InstancesBackupsListRequest
*/
func (a *BackupApiService) V1InstancesBackupsList(ctx context.Context, instanceId string) ApiV1InstancesBackupsListRequest {
	return ApiV1InstancesBackupsListRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return BackupResponse
func (a *BackupApiService) V1InstancesBackupsListExecute(r ApiV1InstancesBackupsListRequest) (*BackupResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BackupResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BackupApiService.V1InstancesBackupsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/backups"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.backupTarget != nil {
		localVarQueryParams.Add("backupTarget", parameterToString(*r.backupTarget, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesBackupRestoresCreateRequest struct {
	ctx context.Context
	ApiService *BackupApiService
	backupDate string
	instanceId string
	projectId string
	authorization *string
	restoreTarget *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesBackupRestoresCreateRequest) Authorization(authorization string) ApiV1ProjectsInstancesBackupRestoresCreateRequest {
	r.authorization = &authorization
	return r
}

// List of restore targets
func (r ApiV1ProjectsInstancesBackupRestoresCreateRequest) RestoreTarget(restoreTarget string) ApiV1ProjectsInstancesBackupRestoresCreateRequest {
	r.restoreTarget = &restoreTarget
	return r
}

func (r ApiV1ProjectsInstancesBackupRestoresCreateRequest) Execute() (*Message, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesBackupRestoresCreateExecute(r)
}

/*
V1ProjectsInstancesBackupRestoresCreate Method for V1ProjectsInstancesBackupRestoresCreate

Restore backup.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param backupDate
 @param instanceId
 @param projectId
 @return ApiV1ProjectsInstancesBackupRestoresCreateRequest
*/
func (a *BackupApiService) V1ProjectsInstancesBackupRestoresCreate(ctx context.Context, backupDate string, instanceId string, projectId string) ApiV1ProjectsInstancesBackupRestoresCreateRequest {
	return ApiV1ProjectsInstancesBackupRestoresCreateRequest{
		ApiService: a,
		ctx: ctx,
		backupDate: backupDate,
		instanceId: instanceId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Message
func (a *BackupApiService) V1ProjectsInstancesBackupRestoresCreateExecute(r ApiV1ProjectsInstancesBackupRestoresCreateRequest) (*Message, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Message
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BackupApiService.V1ProjectsInstancesBackupRestoresCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/backup-restores/{backupDate}"
	localVarPath = strings.Replace(localVarPath, "{"+"backupDate"+"}", url.PathEscape(parameterToString(r.backupDate, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.restoreTarget == nil {
		return localVarReturnValue, nil, reportError("restoreTarget is required and must be specified")
	}

	localVarQueryParams.Add("restoreTarget", parameterToString(*r.restoreTarget, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesBackupRetentionsListRequest struct {
	ctx context.Context
	ApiService *BackupApiService
	instanceId string
	projectId string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesBackupRetentionsListRequest) Authorization(authorization string) ApiV1ProjectsInstancesBackupRetentionsListRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesBackupRetentionsListRequest) Execute() (*BackupRetentionResponse, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesBackupRetentionsListExecute(r)
}

/*
V1ProjectsInstancesBackupRetentionsList Method for V1ProjectsInstancesBackupRetentionsList

Get backup retention.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @param projectId
 @return ApiV1ProjectsInstancesBackupRetentionsListRequest
*/
func (a *BackupApiService) V1ProjectsInstancesBackupRetentionsList(ctx context.Context, instanceId string, projectId string) ApiV1ProjectsInstancesBackupRetentionsListRequest {
	return ApiV1ProjectsInstancesBackupRetentionsListRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return BackupRetentionResponse
func (a *BackupApiService) V1ProjectsInstancesBackupRetentionsListExecute(r ApiV1ProjectsInstancesBackupRetentionsListRequest) (*BackupRetentionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BackupRetentionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BackupApiService.V1ProjectsInstancesBackupRetentionsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/backup-retentions"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesBackupRetentionsUpdateRequest struct {
	ctx context.Context
	ApiService *BackupApiService
	instanceId string
	projectId string
	authorization *string
	data *V1InstancesBackupRetentionsUpdateRequest
	backupTarget *[]string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesBackupRetentionsUpdateRequest) Authorization(authorization string) ApiV1ProjectsInstancesBackupRetentionsUpdateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesBackupRetentionsUpdateRequest) Data(data V1InstancesBackupRetentionsUpdateRequest) ApiV1ProjectsInstancesBackupRetentionsUpdateRequest {
	r.data = &data
	return r
}

// List of backup targets
func (r ApiV1ProjectsInstancesBackupRetentionsUpdateRequest) BackupTarget(backupTarget []string) ApiV1ProjectsInstancesBackupRetentionsUpdateRequest {
	r.backupTarget = &backupTarget
	return r
}

func (r ApiV1ProjectsInstancesBackupRetentionsUpdateRequest) Execute() (*Message, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesBackupRetentionsUpdateExecute(r)
}

/*
V1ProjectsInstancesBackupRetentionsUpdate Method for V1ProjectsInstancesBackupRetentionsUpdate

Update backup retention.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @param projectId
 @return ApiV1ProjectsInstancesBackupRetentionsUpdateRequest
*/
func (a *BackupApiService) V1ProjectsInstancesBackupRetentionsUpdate(ctx context.Context, instanceId string, projectId string) ApiV1ProjectsInstancesBackupRetentionsUpdateRequest {
	return ApiV1ProjectsInstancesBackupRetentionsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Message
func (a *BackupApiService) V1ProjectsInstancesBackupRetentionsUpdateExecute(r ApiV1ProjectsInstancesBackupRetentionsUpdateRequest) (*Message, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Message
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BackupApiService.V1ProjectsInstancesBackupRetentionsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/backup-retentions"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	if r.backupTarget != nil {
		localVarQueryParams.Add("backupTarget", parameterToString(*r.backupTarget, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesBackupSchedulesCreateRequest struct {
	ctx context.Context
	ApiService *BackupApiService
	instanceId string
	projectId string
	authorization *string
	data *V1InstancesBackupSchedulesCreateRequest
	backupTarget *[]string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesBackupSchedulesCreateRequest) Authorization(authorization string) ApiV1ProjectsInstancesBackupSchedulesCreateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesBackupSchedulesCreateRequest) Data(data V1InstancesBackupSchedulesCreateRequest) ApiV1ProjectsInstancesBackupSchedulesCreateRequest {
	r.data = &data
	return r
}

// List of backup targets
func (r ApiV1ProjectsInstancesBackupSchedulesCreateRequest) BackupTarget(backupTarget []string) ApiV1ProjectsInstancesBackupSchedulesCreateRequest {
	r.backupTarget = &backupTarget
	return r
}

func (r ApiV1ProjectsInstancesBackupSchedulesCreateRequest) Execute() (*BackupSchedulePostResponse, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesBackupSchedulesCreateExecute(r)
}

/*
V1ProjectsInstancesBackupSchedulesCreate Method for V1ProjectsInstancesBackupSchedulesCreate

Create backup schedule.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @param projectId
 @return ApiV1ProjectsInstancesBackupSchedulesCreateRequest
*/
func (a *BackupApiService) V1ProjectsInstancesBackupSchedulesCreate(ctx context.Context, instanceId string, projectId string) ApiV1ProjectsInstancesBackupSchedulesCreateRequest {
	return ApiV1ProjectsInstancesBackupSchedulesCreateRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return BackupSchedulePostResponse
func (a *BackupApiService) V1ProjectsInstancesBackupSchedulesCreateExecute(r ApiV1ProjectsInstancesBackupSchedulesCreateRequest) (*BackupSchedulePostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BackupSchedulePostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BackupApiService.V1ProjectsInstancesBackupSchedulesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/backup-schedules"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	if r.backupTarget != nil {
		localVarQueryParams.Add("backupTarget", parameterToString(*r.backupTarget, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesBackupSchedulesDeleteRequest struct {
	ctx context.Context
	ApiService *BackupApiService
	instanceId string
	projectId string
	scheduleId string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesBackupSchedulesDeleteRequest) Authorization(authorization string) ApiV1ProjectsInstancesBackupSchedulesDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesBackupSchedulesDeleteRequest) Execute() (*Message, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesBackupSchedulesDeleteExecute(r)
}

/*
V1ProjectsInstancesBackupSchedulesDelete Method for V1ProjectsInstancesBackupSchedulesDelete

Delete backup schedule.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @param projectId
 @param scheduleId
 @return ApiV1ProjectsInstancesBackupSchedulesDeleteRequest
*/
func (a *BackupApiService) V1ProjectsInstancesBackupSchedulesDelete(ctx context.Context, instanceId string, projectId string, scheduleId string) ApiV1ProjectsInstancesBackupSchedulesDeleteRequest {
	return ApiV1ProjectsInstancesBackupSchedulesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
		projectId: projectId,
		scheduleId: scheduleId,
	}
}

// Execute executes the request
//  @return Message
func (a *BackupApiService) V1ProjectsInstancesBackupSchedulesDeleteExecute(r ApiV1ProjectsInstancesBackupSchedulesDeleteRequest) (*Message, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Message
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BackupApiService.V1ProjectsInstancesBackupSchedulesDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/backup-schedules/{scheduleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scheduleId"+"}", url.PathEscape(parameterToString(r.scheduleId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesBackupSchedulesListRequest struct {
	ctx context.Context
	ApiService *BackupApiService
	instanceId string
	projectId string
	authorization *string
	backupTarget *[]string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesBackupSchedulesListRequest) Authorization(authorization string) ApiV1ProjectsInstancesBackupSchedulesListRequest {
	r.authorization = &authorization
	return r
}

// List of backup targets
func (r ApiV1ProjectsInstancesBackupSchedulesListRequest) BackupTarget(backupTarget []string) ApiV1ProjectsInstancesBackupSchedulesListRequest {
	r.backupTarget = &backupTarget
	return r
}

func (r ApiV1ProjectsInstancesBackupSchedulesListRequest) Execute() (*BackupScheduleResponse, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesBackupSchedulesListExecute(r)
}

/*
V1ProjectsInstancesBackupSchedulesList Method for V1ProjectsInstancesBackupSchedulesList

Get backup schedules.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @param projectId
 @return ApiV1ProjectsInstancesBackupSchedulesListRequest
*/
func (a *BackupApiService) V1ProjectsInstancesBackupSchedulesList(ctx context.Context, instanceId string, projectId string) ApiV1ProjectsInstancesBackupSchedulesListRequest {
	return ApiV1ProjectsInstancesBackupSchedulesListRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return BackupScheduleResponse
func (a *BackupApiService) V1ProjectsInstancesBackupSchedulesListExecute(r ApiV1ProjectsInstancesBackupSchedulesListRequest) (*BackupScheduleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BackupScheduleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BackupApiService.V1ProjectsInstancesBackupSchedulesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/backup-schedules"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.backupTarget != nil {
		localVarQueryParams.Add("backupTarget", parameterToString(*r.backupTarget, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesBackupSchedulesUpdateRequest struct {
	ctx context.Context
	ApiService *BackupApiService
	instanceId string
	projectId string
	scheduleId string
	authorization *string
	data *V1InstancesBackupSchedulesCreateRequest
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesBackupSchedulesUpdateRequest) Authorization(authorization string) ApiV1ProjectsInstancesBackupSchedulesUpdateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesBackupSchedulesUpdateRequest) Data(data V1InstancesBackupSchedulesCreateRequest) ApiV1ProjectsInstancesBackupSchedulesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiV1ProjectsInstancesBackupSchedulesUpdateRequest) Execute() (*BackupSchedulePutResponse, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesBackupSchedulesUpdateExecute(r)
}

/*
V1ProjectsInstancesBackupSchedulesUpdate Method for V1ProjectsInstancesBackupSchedulesUpdate

Update backup schedule.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @param projectId
 @param scheduleId
 @return ApiV1ProjectsInstancesBackupSchedulesUpdateRequest
*/
func (a *BackupApiService) V1ProjectsInstancesBackupSchedulesUpdate(ctx context.Context, instanceId string, projectId string, scheduleId string) ApiV1ProjectsInstancesBackupSchedulesUpdateRequest {
	return ApiV1ProjectsInstancesBackupSchedulesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
		projectId: projectId,
		scheduleId: scheduleId,
	}
}

// Execute executes the request
//  @return BackupSchedulePutResponse
func (a *BackupApiService) V1ProjectsInstancesBackupSchedulesUpdateExecute(r ApiV1ProjectsInstancesBackupSchedulesUpdateRequest) (*BackupSchedulePutResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BackupSchedulePutResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BackupApiService.V1ProjectsInstancesBackupSchedulesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/backup-schedules/{scheduleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scheduleId"+"}", url.PathEscape(parameterToString(r.scheduleId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesBackupsCreateRequest struct {
	ctx context.Context
	ApiService *BackupApiService
	instanceId string
	projectId string
	authorization *string
	backupTarget *[]string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesBackupsCreateRequest) Authorization(authorization string) ApiV1ProjectsInstancesBackupsCreateRequest {
	r.authorization = &authorization
	return r
}

// List of backup targets
func (r ApiV1ProjectsInstancesBackupsCreateRequest) BackupTarget(backupTarget []string) ApiV1ProjectsInstancesBackupsCreateRequest {
	r.backupTarget = &backupTarget
	return r
}

func (r ApiV1ProjectsInstancesBackupsCreateRequest) Execute() (*Message, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesBackupsCreateExecute(r)
}

/*
V1ProjectsInstancesBackupsCreate Method for V1ProjectsInstancesBackupsCreate

Create a backup.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @param projectId
 @return ApiV1ProjectsInstancesBackupsCreateRequest
*/
func (a *BackupApiService) V1ProjectsInstancesBackupsCreate(ctx context.Context, instanceId string, projectId string) ApiV1ProjectsInstancesBackupsCreateRequest {
	return ApiV1ProjectsInstancesBackupsCreateRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Message
func (a *BackupApiService) V1ProjectsInstancesBackupsCreateExecute(r ApiV1ProjectsInstancesBackupsCreateRequest) (*Message, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Message
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BackupApiService.V1ProjectsInstancesBackupsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/backups"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.backupTarget != nil {
		localVarQueryParams.Add("backupTarget", parameterToString(*r.backupTarget, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesBackupsDeleteRequest struct {
	ctx context.Context
	ApiService *BackupApiService
	backupDate string
	instanceId string
	projectId string
	authorization *string
	backupTarget *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesBackupsDeleteRequest) Authorization(authorization string) ApiV1ProjectsInstancesBackupsDeleteRequest {
	r.authorization = &authorization
	return r
}

// Backup target selector
func (r ApiV1ProjectsInstancesBackupsDeleteRequest) BackupTarget(backupTarget string) ApiV1ProjectsInstancesBackupsDeleteRequest {
	r.backupTarget = &backupTarget
	return r
}

func (r ApiV1ProjectsInstancesBackupsDeleteRequest) Execute() (*Message, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesBackupsDeleteExecute(r)
}

/*
V1ProjectsInstancesBackupsDelete Method for V1ProjectsInstancesBackupsDelete

Delete backup.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param backupDate
 @param instanceId
 @param projectId
 @return ApiV1ProjectsInstancesBackupsDeleteRequest
*/
func (a *BackupApiService) V1ProjectsInstancesBackupsDelete(ctx context.Context, backupDate string, instanceId string, projectId string) ApiV1ProjectsInstancesBackupsDeleteRequest {
	return ApiV1ProjectsInstancesBackupsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		backupDate: backupDate,
		instanceId: instanceId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Message
func (a *BackupApiService) V1ProjectsInstancesBackupsDeleteExecute(r ApiV1ProjectsInstancesBackupsDeleteRequest) (*Message, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Message
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BackupApiService.V1ProjectsInstancesBackupsDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/backups/{backupDate}"
	localVarPath = strings.Replace(localVarPath, "{"+"backupDate"+"}", url.PathEscape(parameterToString(r.backupDate, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.backupTarget == nil {
		return localVarReturnValue, nil, reportError("backupTarget is required and must be specified")
	}

	localVarQueryParams.Add("backupTarget", parameterToString(*r.backupTarget, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesBackupsListRequest struct {
	ctx context.Context
	ApiService *BackupApiService
	instanceId string
	projectId string
	authorization *string
	backupTarget *[]string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesBackupsListRequest) Authorization(authorization string) ApiV1ProjectsInstancesBackupsListRequest {
	r.authorization = &authorization
	return r
}

// List of backup targets
func (r ApiV1ProjectsInstancesBackupsListRequest) BackupTarget(backupTarget []string) ApiV1ProjectsInstancesBackupsListRequest {
	r.backupTarget = &backupTarget
	return r
}

func (r ApiV1ProjectsInstancesBackupsListRequest) Execute() (*BackupResponse, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesBackupsListExecute(r)
}

/*
V1ProjectsInstancesBackupsList Method for V1ProjectsInstancesBackupsList

Get backups.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @param projectId
 @return ApiV1ProjectsInstancesBackupsListRequest
*/
func (a *BackupApiService) V1ProjectsInstancesBackupsList(ctx context.Context, instanceId string, projectId string) ApiV1ProjectsInstancesBackupsListRequest {
	return ApiV1ProjectsInstancesBackupsListRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return BackupResponse
func (a *BackupApiService) V1ProjectsInstancesBackupsListExecute(r ApiV1ProjectsInstancesBackupsListRequest) (*BackupResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BackupResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BackupApiService.V1ProjectsInstancesBackupsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/backups"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.backupTarget != nil {
		localVarQueryParams.Add("backupTarget", parameterToString(*r.backupTarget, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
