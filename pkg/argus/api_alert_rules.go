/*
STACKIT Argus API

API endpoints for Argus on STACKIT

API version: v1
Contact: stackit-argus@mail.schwarz
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package argus

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// AlertRulesApiService AlertRulesApi service
type AlertRulesApiService service

type ApiV1InstancesAlertgroupsAlertrulesCreateRequest struct {
	ctx context.Context
	ApiService *AlertRulesApiService
	groupName string
	instanceId string
	authorization *string
	data *V1InstancesAlertgroupsCreateRequestRulesInner
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesAlertgroupsAlertrulesCreateRequest) Authorization(authorization string) ApiV1InstancesAlertgroupsAlertrulesCreateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertgroupsAlertrulesCreateRequest) Data(data V1InstancesAlertgroupsCreateRequestRulesInner) ApiV1InstancesAlertgroupsAlertrulesCreateRequest {
	r.data = &data
	return r
}

func (r ApiV1InstancesAlertgroupsAlertrulesCreateRequest) Execute() (*AlertRulesResponse, *http.Response, error) {
	return r.ApiService.V1InstancesAlertgroupsAlertrulesCreateExecute(r)
}

/*
V1InstancesAlertgroupsAlertrulesCreate Method for V1InstancesAlertgroupsAlertrulesCreate

Create alert rule.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName
 @param instanceId
 @return ApiV1InstancesAlertgroupsAlertrulesCreateRequest
*/
func (a *AlertRulesApiService) V1InstancesAlertgroupsAlertrulesCreate(ctx context.Context, groupName string, instanceId string) ApiV1InstancesAlertgroupsAlertrulesCreateRequest {
	return ApiV1InstancesAlertgroupsAlertrulesCreateRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return AlertRulesResponse
func (a *AlertRulesApiService) V1InstancesAlertgroupsAlertrulesCreateExecute(r ApiV1InstancesAlertgroupsAlertrulesCreateRequest) (*AlertRulesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertRulesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRulesApiService.V1InstancesAlertgroupsAlertrulesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertgroups/{groupName}/alertrules"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesAlertgroupsAlertrulesDeleteRequest struct {
	ctx context.Context
	ApiService *AlertRulesApiService
	groupName string
	instanceId string
	authorization *string
	alertName *[]string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesAlertgroupsAlertrulesDeleteRequest) Authorization(authorization string) ApiV1InstancesAlertgroupsAlertrulesDeleteRequest {
	r.authorization = &authorization
	return r
}

// Name of the alert rules that should be deleted
func (r ApiV1InstancesAlertgroupsAlertrulesDeleteRequest) AlertName(alertName []string) ApiV1InstancesAlertgroupsAlertrulesDeleteRequest {
	r.alertName = &alertName
	return r
}

func (r ApiV1InstancesAlertgroupsAlertrulesDeleteRequest) Execute() (*AlertRulesResponse, *http.Response, error) {
	return r.ApiService.V1InstancesAlertgroupsAlertrulesDeleteExecute(r)
}

/*
V1InstancesAlertgroupsAlertrulesDelete Method for V1InstancesAlertgroupsAlertrulesDelete

Delete alert rules.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName
 @param instanceId
 @return ApiV1InstancesAlertgroupsAlertrulesDeleteRequest
*/
func (a *AlertRulesApiService) V1InstancesAlertgroupsAlertrulesDelete(ctx context.Context, groupName string, instanceId string) ApiV1InstancesAlertgroupsAlertrulesDeleteRequest {
	return ApiV1InstancesAlertgroupsAlertrulesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return AlertRulesResponse
func (a *AlertRulesApiService) V1InstancesAlertgroupsAlertrulesDeleteExecute(r ApiV1InstancesAlertgroupsAlertrulesDeleteRequest) (*AlertRulesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertRulesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRulesApiService.V1InstancesAlertgroupsAlertrulesDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertgroups/{groupName}/alertrules"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.alertName == nil {
		return localVarReturnValue, nil, reportError("alertName is required and must be specified")
	}

	localVarQueryParams.Add("alertName", parameterToString(*r.alertName, "csv"))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesAlertgroupsAlertrulesDelete_0Request struct {
	ctx context.Context
	ApiService *AlertRulesApiService
	alertName string
	groupName string
	instanceId string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesAlertgroupsAlertrulesDelete_0Request) Authorization(authorization string) ApiV1InstancesAlertgroupsAlertrulesDelete_0Request {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertgroupsAlertrulesDelete_0Request) Execute() (*AlertRulesResponse, *http.Response, error) {
	return r.ApiService.V1InstancesAlertgroupsAlertrulesDelete_1Execute(r)
}

/*
V1InstancesAlertgroupsAlertrulesDelete_0 Method for V1InstancesAlertgroupsAlertrulesDelete_0

Delete alert rule.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param alertName
 @param groupName
 @param instanceId
 @return ApiV1InstancesAlertgroupsAlertrulesDelete_0Request
*/
func (a *AlertRulesApiService) V1InstancesAlertgroupsAlertrulesDelete_1(ctx context.Context, alertName string, groupName string, instanceId string) ApiV1InstancesAlertgroupsAlertrulesDelete_0Request {
	return ApiV1InstancesAlertgroupsAlertrulesDelete_0Request{
		ApiService: a,
		ctx: ctx,
		alertName: alertName,
		groupName: groupName,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return AlertRulesResponse
func (a *AlertRulesApiService) V1InstancesAlertgroupsAlertrulesDelete_1Execute(r ApiV1InstancesAlertgroupsAlertrulesDelete_0Request) (*AlertRulesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertRulesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRulesApiService.V1InstancesAlertgroupsAlertrulesDelete_1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertgroups/{groupName}/alertrules/{alertName}"
	localVarPath = strings.Replace(localVarPath, "{"+"alertName"+"}", url.PathEscape(parameterToString(r.alertName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesAlertgroupsAlertrulesListRequest struct {
	ctx context.Context
	ApiService *AlertRulesApiService
	groupName string
	instanceId string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesAlertgroupsAlertrulesListRequest) Authorization(authorization string) ApiV1InstancesAlertgroupsAlertrulesListRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertgroupsAlertrulesListRequest) Execute() (*AlertRulesResponse, *http.Response, error) {
	return r.ApiService.V1InstancesAlertgroupsAlertrulesListExecute(r)
}

/*
V1InstancesAlertgroupsAlertrulesList Method for V1InstancesAlertgroupsAlertrulesList

Get alert rules.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName
 @param instanceId
 @return ApiV1InstancesAlertgroupsAlertrulesListRequest
*/
func (a *AlertRulesApiService) V1InstancesAlertgroupsAlertrulesList(ctx context.Context, groupName string, instanceId string) ApiV1InstancesAlertgroupsAlertrulesListRequest {
	return ApiV1InstancesAlertgroupsAlertrulesListRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return AlertRulesResponse
func (a *AlertRulesApiService) V1InstancesAlertgroupsAlertrulesListExecute(r ApiV1InstancesAlertgroupsAlertrulesListRequest) (*AlertRulesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertRulesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRulesApiService.V1InstancesAlertgroupsAlertrulesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertgroups/{groupName}/alertrules"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesAlertgroupsAlertrulesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *AlertRulesApiService
	groupName string
	instanceId string
	authorization *string
	data *[]V1InstancesAlertgroupsCreateRequestRulesInner
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesAlertgroupsAlertrulesPartialUpdateRequest) Authorization(authorization string) ApiV1InstancesAlertgroupsAlertrulesPartialUpdateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertgroupsAlertrulesPartialUpdateRequest) Data(data []V1InstancesAlertgroupsCreateRequestRulesInner) ApiV1InstancesAlertgroupsAlertrulesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiV1InstancesAlertgroupsAlertrulesPartialUpdateRequest) Execute() (*AlertRulesResponse, *http.Response, error) {
	return r.ApiService.V1InstancesAlertgroupsAlertrulesPartialUpdateExecute(r)
}

/*
V1InstancesAlertgroupsAlertrulesPartialUpdate Method for V1InstancesAlertgroupsAlertrulesPartialUpdate

Patch alert rules.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName
 @param instanceId
 @return ApiV1InstancesAlertgroupsAlertrulesPartialUpdateRequest
*/
func (a *AlertRulesApiService) V1InstancesAlertgroupsAlertrulesPartialUpdate(ctx context.Context, groupName string, instanceId string) ApiV1InstancesAlertgroupsAlertrulesPartialUpdateRequest {
	return ApiV1InstancesAlertgroupsAlertrulesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return AlertRulesResponse
func (a *AlertRulesApiService) V1InstancesAlertgroupsAlertrulesPartialUpdateExecute(r ApiV1InstancesAlertgroupsAlertrulesPartialUpdateRequest) (*AlertRulesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertRulesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRulesApiService.V1InstancesAlertgroupsAlertrulesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertgroups/{groupName}/alertrules"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesAlertgroupsAlertrulesReadRequest struct {
	ctx context.Context
	ApiService *AlertRulesApiService
	alertName string
	groupName string
	instanceId string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesAlertgroupsAlertrulesReadRequest) Authorization(authorization string) ApiV1InstancesAlertgroupsAlertrulesReadRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertgroupsAlertrulesReadRequest) Execute() (*AlertRuleResponse, *http.Response, error) {
	return r.ApiService.V1InstancesAlertgroupsAlertrulesReadExecute(r)
}

/*
V1InstancesAlertgroupsAlertrulesRead Method for V1InstancesAlertgroupsAlertrulesRead

Get alert rule.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param alertName
 @param groupName
 @param instanceId
 @return ApiV1InstancesAlertgroupsAlertrulesReadRequest
*/
func (a *AlertRulesApiService) V1InstancesAlertgroupsAlertrulesRead(ctx context.Context, alertName string, groupName string, instanceId string) ApiV1InstancesAlertgroupsAlertrulesReadRequest {
	return ApiV1InstancesAlertgroupsAlertrulesReadRequest{
		ApiService: a,
		ctx: ctx,
		alertName: alertName,
		groupName: groupName,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return AlertRuleResponse
func (a *AlertRulesApiService) V1InstancesAlertgroupsAlertrulesReadExecute(r ApiV1InstancesAlertgroupsAlertrulesReadRequest) (*AlertRuleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertRuleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRulesApiService.V1InstancesAlertgroupsAlertrulesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertgroups/{groupName}/alertrules/{alertName}"
	localVarPath = strings.Replace(localVarPath, "{"+"alertName"+"}", url.PathEscape(parameterToString(r.alertName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesAlertgroupsAlertrulesUpdateRequest struct {
	ctx context.Context
	ApiService *AlertRulesApiService
	alertName string
	groupName string
	instanceId string
	authorization *string
	data *V1InstancesAlertgroupsAlertrulesUpdateRequest
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesAlertgroupsAlertrulesUpdateRequest) Authorization(authorization string) ApiV1InstancesAlertgroupsAlertrulesUpdateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertgroupsAlertrulesUpdateRequest) Data(data V1InstancesAlertgroupsAlertrulesUpdateRequest) ApiV1InstancesAlertgroupsAlertrulesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiV1InstancesAlertgroupsAlertrulesUpdateRequest) Execute() (*AlertRulesResponse, *http.Response, error) {
	return r.ApiService.V1InstancesAlertgroupsAlertrulesUpdateExecute(r)
}

/*
V1InstancesAlertgroupsAlertrulesUpdate Method for V1InstancesAlertgroupsAlertrulesUpdate

Update alert rule.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param alertName
 @param groupName
 @param instanceId
 @return ApiV1InstancesAlertgroupsAlertrulesUpdateRequest
*/
func (a *AlertRulesApiService) V1InstancesAlertgroupsAlertrulesUpdate(ctx context.Context, alertName string, groupName string, instanceId string) ApiV1InstancesAlertgroupsAlertrulesUpdateRequest {
	return ApiV1InstancesAlertgroupsAlertrulesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		alertName: alertName,
		groupName: groupName,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return AlertRulesResponse
func (a *AlertRulesApiService) V1InstancesAlertgroupsAlertrulesUpdateExecute(r ApiV1InstancesAlertgroupsAlertrulesUpdateRequest) (*AlertRulesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertRulesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRulesApiService.V1InstancesAlertgroupsAlertrulesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertgroups/{groupName}/alertrules/{alertName}"
	localVarPath = strings.Replace(localVarPath, "{"+"alertName"+"}", url.PathEscape(parameterToString(r.alertName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertgroupsAlertrulesCreateRequest struct {
	ctx context.Context
	ApiService *AlertRulesApiService
	groupName string
	instanceId string
	projectId string
	authorization *string
	data *V1InstancesAlertgroupsCreateRequestRulesInner
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesCreateRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertgroupsAlertrulesCreateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesCreateRequest) Data(data V1InstancesAlertgroupsCreateRequestRulesInner) ApiV1ProjectsInstancesAlertgroupsAlertrulesCreateRequest {
	r.data = &data
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesCreateRequest) Execute() (*AlertRulesResponse, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertgroupsAlertrulesCreateExecute(r)
}

/*
V1ProjectsInstancesAlertgroupsAlertrulesCreate Method for V1ProjectsInstancesAlertgroupsAlertrulesCreate

Create alert rule.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName
 @param instanceId
 @param projectId
 @return ApiV1ProjectsInstancesAlertgroupsAlertrulesCreateRequest
*/
func (a *AlertRulesApiService) V1ProjectsInstancesAlertgroupsAlertrulesCreate(ctx context.Context, groupName string, instanceId string, projectId string) ApiV1ProjectsInstancesAlertgroupsAlertrulesCreateRequest {
	return ApiV1ProjectsInstancesAlertgroupsAlertrulesCreateRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		instanceId: instanceId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return AlertRulesResponse
func (a *AlertRulesApiService) V1ProjectsInstancesAlertgroupsAlertrulesCreateExecute(r ApiV1ProjectsInstancesAlertgroupsAlertrulesCreateRequest) (*AlertRulesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertRulesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRulesApiService.V1ProjectsInstancesAlertgroupsAlertrulesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertgroups/{groupName}/alertrules"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertgroupsAlertrulesDeleteRequest struct {
	ctx context.Context
	ApiService *AlertRulesApiService
	groupName string
	instanceId string
	projectId string
	authorization *string
	alertName *[]string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesDeleteRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertgroupsAlertrulesDeleteRequest {
	r.authorization = &authorization
	return r
}

// Name of the alert rules that should be deleted
func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesDeleteRequest) AlertName(alertName []string) ApiV1ProjectsInstancesAlertgroupsAlertrulesDeleteRequest {
	r.alertName = &alertName
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesDeleteRequest) Execute() (*AlertRulesResponse, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertgroupsAlertrulesDeleteExecute(r)
}

/*
V1ProjectsInstancesAlertgroupsAlertrulesDelete Method for V1ProjectsInstancesAlertgroupsAlertrulesDelete

Delete alert rules.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName
 @param instanceId
 @param projectId
 @return ApiV1ProjectsInstancesAlertgroupsAlertrulesDeleteRequest
*/
func (a *AlertRulesApiService) V1ProjectsInstancesAlertgroupsAlertrulesDelete(ctx context.Context, groupName string, instanceId string, projectId string) ApiV1ProjectsInstancesAlertgroupsAlertrulesDeleteRequest {
	return ApiV1ProjectsInstancesAlertgroupsAlertrulesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		instanceId: instanceId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return AlertRulesResponse
func (a *AlertRulesApiService) V1ProjectsInstancesAlertgroupsAlertrulesDeleteExecute(r ApiV1ProjectsInstancesAlertgroupsAlertrulesDeleteRequest) (*AlertRulesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertRulesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRulesApiService.V1ProjectsInstancesAlertgroupsAlertrulesDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertgroups/{groupName}/alertrules"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.alertName == nil {
		return localVarReturnValue, nil, reportError("alertName is required and must be specified")
	}

	localVarQueryParams.Add("alertName", parameterToString(*r.alertName, "csv"))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertgroupsAlertrulesDelete_0Request struct {
	ctx context.Context
	ApiService *AlertRulesApiService
	alertName string
	groupName string
	instanceId string
	projectId string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesDelete_0Request) Authorization(authorization string) ApiV1ProjectsInstancesAlertgroupsAlertrulesDelete_0Request {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesDelete_0Request) Execute() (*AlertRulesResponse, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertgroupsAlertrulesDelete_2Execute(r)
}

/*
V1ProjectsInstancesAlertgroupsAlertrulesDelete_0 Method for V1ProjectsInstancesAlertgroupsAlertrulesDelete_0

Delete alert rule.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param alertName
 @param groupName
 @param instanceId
 @param projectId
 @return ApiV1ProjectsInstancesAlertgroupsAlertrulesDelete_0Request
*/
func (a *AlertRulesApiService) V1ProjectsInstancesAlertgroupsAlertrulesDelete_2(ctx context.Context, alertName string, groupName string, instanceId string, projectId string) ApiV1ProjectsInstancesAlertgroupsAlertrulesDelete_0Request {
	return ApiV1ProjectsInstancesAlertgroupsAlertrulesDelete_0Request{
		ApiService: a,
		ctx: ctx,
		alertName: alertName,
		groupName: groupName,
		instanceId: instanceId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return AlertRulesResponse
func (a *AlertRulesApiService) V1ProjectsInstancesAlertgroupsAlertrulesDelete_2Execute(r ApiV1ProjectsInstancesAlertgroupsAlertrulesDelete_0Request) (*AlertRulesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertRulesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRulesApiService.V1ProjectsInstancesAlertgroupsAlertrulesDelete_2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertgroups/{groupName}/alertrules/{alertName}"
	localVarPath = strings.Replace(localVarPath, "{"+"alertName"+"}", url.PathEscape(parameterToString(r.alertName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertgroupsAlertrulesListRequest struct {
	ctx context.Context
	ApiService *AlertRulesApiService
	groupName string
	instanceId string
	projectId string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesListRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertgroupsAlertrulesListRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesListRequest) Execute() (*AlertRulesResponse, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertgroupsAlertrulesListExecute(r)
}

/*
V1ProjectsInstancesAlertgroupsAlertrulesList Method for V1ProjectsInstancesAlertgroupsAlertrulesList

Get alert rules.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName
 @param instanceId
 @param projectId
 @return ApiV1ProjectsInstancesAlertgroupsAlertrulesListRequest
*/
func (a *AlertRulesApiService) V1ProjectsInstancesAlertgroupsAlertrulesList(ctx context.Context, groupName string, instanceId string, projectId string) ApiV1ProjectsInstancesAlertgroupsAlertrulesListRequest {
	return ApiV1ProjectsInstancesAlertgroupsAlertrulesListRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		instanceId: instanceId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return AlertRulesResponse
func (a *AlertRulesApiService) V1ProjectsInstancesAlertgroupsAlertrulesListExecute(r ApiV1ProjectsInstancesAlertgroupsAlertrulesListRequest) (*AlertRulesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertRulesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRulesApiService.V1ProjectsInstancesAlertgroupsAlertrulesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertgroups/{groupName}/alertrules"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertgroupsAlertrulesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *AlertRulesApiService
	groupName string
	instanceId string
	projectId string
	authorization *string
	data *[]V1InstancesAlertgroupsCreateRequestRulesInner
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesPartialUpdateRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertgroupsAlertrulesPartialUpdateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesPartialUpdateRequest) Data(data []V1InstancesAlertgroupsCreateRequestRulesInner) ApiV1ProjectsInstancesAlertgroupsAlertrulesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesPartialUpdateRequest) Execute() (*AlertRulesResponse, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertgroupsAlertrulesPartialUpdateExecute(r)
}

/*
V1ProjectsInstancesAlertgroupsAlertrulesPartialUpdate Method for V1ProjectsInstancesAlertgroupsAlertrulesPartialUpdate

Patch alert rules.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName
 @param instanceId
 @param projectId
 @return ApiV1ProjectsInstancesAlertgroupsAlertrulesPartialUpdateRequest
*/
func (a *AlertRulesApiService) V1ProjectsInstancesAlertgroupsAlertrulesPartialUpdate(ctx context.Context, groupName string, instanceId string, projectId string) ApiV1ProjectsInstancesAlertgroupsAlertrulesPartialUpdateRequest {
	return ApiV1ProjectsInstancesAlertgroupsAlertrulesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		instanceId: instanceId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return AlertRulesResponse
func (a *AlertRulesApiService) V1ProjectsInstancesAlertgroupsAlertrulesPartialUpdateExecute(r ApiV1ProjectsInstancesAlertgroupsAlertrulesPartialUpdateRequest) (*AlertRulesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertRulesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRulesApiService.V1ProjectsInstancesAlertgroupsAlertrulesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertgroups/{groupName}/alertrules"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertgroupsAlertrulesReadRequest struct {
	ctx context.Context
	ApiService *AlertRulesApiService
	alertName string
	groupName string
	instanceId string
	projectId string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesReadRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertgroupsAlertrulesReadRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesReadRequest) Execute() (*AlertRuleResponse, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertgroupsAlertrulesReadExecute(r)
}

/*
V1ProjectsInstancesAlertgroupsAlertrulesRead Method for V1ProjectsInstancesAlertgroupsAlertrulesRead

Get alert rule.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param alertName
 @param groupName
 @param instanceId
 @param projectId
 @return ApiV1ProjectsInstancesAlertgroupsAlertrulesReadRequest
*/
func (a *AlertRulesApiService) V1ProjectsInstancesAlertgroupsAlertrulesRead(ctx context.Context, alertName string, groupName string, instanceId string, projectId string) ApiV1ProjectsInstancesAlertgroupsAlertrulesReadRequest {
	return ApiV1ProjectsInstancesAlertgroupsAlertrulesReadRequest{
		ApiService: a,
		ctx: ctx,
		alertName: alertName,
		groupName: groupName,
		instanceId: instanceId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return AlertRuleResponse
func (a *AlertRulesApiService) V1ProjectsInstancesAlertgroupsAlertrulesReadExecute(r ApiV1ProjectsInstancesAlertgroupsAlertrulesReadRequest) (*AlertRuleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertRuleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRulesApiService.V1ProjectsInstancesAlertgroupsAlertrulesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertgroups/{groupName}/alertrules/{alertName}"
	localVarPath = strings.Replace(localVarPath, "{"+"alertName"+"}", url.PathEscape(parameterToString(r.alertName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertgroupsAlertrulesUpdateRequest struct {
	ctx context.Context
	ApiService *AlertRulesApiService
	alertName string
	groupName string
	instanceId string
	projectId string
	authorization *string
	data *V1InstancesAlertgroupsAlertrulesUpdateRequest
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesUpdateRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertgroupsAlertrulesUpdateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesUpdateRequest) Data(data V1InstancesAlertgroupsAlertrulesUpdateRequest) ApiV1ProjectsInstancesAlertgroupsAlertrulesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesUpdateRequest) Execute() (*AlertRulesResponse, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertgroupsAlertrulesUpdateExecute(r)
}

/*
V1ProjectsInstancesAlertgroupsAlertrulesUpdate Method for V1ProjectsInstancesAlertgroupsAlertrulesUpdate

Update alert rule.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param alertName
 @param groupName
 @param instanceId
 @param projectId
 @return ApiV1ProjectsInstancesAlertgroupsAlertrulesUpdateRequest
*/
func (a *AlertRulesApiService) V1ProjectsInstancesAlertgroupsAlertrulesUpdate(ctx context.Context, alertName string, groupName string, instanceId string, projectId string) ApiV1ProjectsInstancesAlertgroupsAlertrulesUpdateRequest {
	return ApiV1ProjectsInstancesAlertgroupsAlertrulesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		alertName: alertName,
		groupName: groupName,
		instanceId: instanceId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return AlertRulesResponse
func (a *AlertRulesApiService) V1ProjectsInstancesAlertgroupsAlertrulesUpdateExecute(r ApiV1ProjectsInstancesAlertgroupsAlertrulesUpdateRequest) (*AlertRulesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertRulesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRulesApiService.V1ProjectsInstancesAlertgroupsAlertrulesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertgroups/{groupName}/alertrules/{alertName}"
	localVarPath = strings.Replace(localVarPath, "{"+"alertName"+"}", url.PathEscape(parameterToString(r.alertName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
