/*
STACKIT Argus API

API endpoints for Argus on STACKIT

API version: v1
Contact: stackit-argus@mail.schwarz
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package argus

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// AlertConfigApiService AlertConfigApi service
type AlertConfigApiService service

type ApiV1InstancesAlertconfigsListRequest struct {
	ctx context.Context
	ApiService *AlertConfigApiService
	instanceId string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesAlertconfigsListRequest) Authorization(authorization string) ApiV1InstancesAlertconfigsListRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertconfigsListRequest) Execute() (*GetAlert, *http.Response, error) {
	return r.ApiService.V1InstancesAlertconfigsListExecute(r)
}

/*
V1InstancesAlertconfigsList Method for V1InstancesAlertconfigsList

Get alert config.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @return ApiV1InstancesAlertconfigsListRequest
*/
func (a *AlertConfigApiService) V1InstancesAlertconfigsList(ctx context.Context, instanceId string) ApiV1InstancesAlertconfigsListRequest {
	return ApiV1InstancesAlertconfigsListRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return GetAlert
func (a *AlertConfigApiService) V1InstancesAlertconfigsListExecute(r ApiV1InstancesAlertconfigsListRequest) (*GetAlert, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAlert
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertConfigApiService.V1InstancesAlertconfigsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertconfigs"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesAlertconfigsReceiversCreateRequest struct {
	ctx context.Context
	ApiService *AlertConfigApiService
	instanceId string
	authorization *string
	data *V1InstancesAlertconfigsUpdateRequestReceiversInner
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesAlertconfigsReceiversCreateRequest) Authorization(authorization string) ApiV1InstancesAlertconfigsReceiversCreateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertconfigsReceiversCreateRequest) Data(data V1InstancesAlertconfigsUpdateRequestReceiversInner) ApiV1InstancesAlertconfigsReceiversCreateRequest {
	r.data = &data
	return r
}

func (r ApiV1InstancesAlertconfigsReceiversCreateRequest) Execute() (*ReceiversResponse, *http.Response, error) {
	return r.ApiService.V1InstancesAlertconfigsReceiversCreateExecute(r)
}

/*
V1InstancesAlertconfigsReceiversCreate Method for V1InstancesAlertconfigsReceiversCreate

Create alert config receiver.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @return ApiV1InstancesAlertconfigsReceiversCreateRequest
*/
func (a *AlertConfigApiService) V1InstancesAlertconfigsReceiversCreate(ctx context.Context, instanceId string) ApiV1InstancesAlertconfigsReceiversCreateRequest {
	return ApiV1InstancesAlertconfigsReceiversCreateRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return ReceiversResponse
func (a *AlertConfigApiService) V1InstancesAlertconfigsReceiversCreateExecute(r ApiV1InstancesAlertconfigsReceiversCreateRequest) (*ReceiversResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReceiversResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertConfigApiService.V1InstancesAlertconfigsReceiversCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertconfigs/receivers"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesAlertconfigsReceiversDeleteRequest struct {
	ctx context.Context
	ApiService *AlertConfigApiService
	instanceId string
	receiver string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesAlertconfigsReceiversDeleteRequest) Authorization(authorization string) ApiV1InstancesAlertconfigsReceiversDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertconfigsReceiversDeleteRequest) Execute() (*ReceiversResponse, *http.Response, error) {
	return r.ApiService.V1InstancesAlertconfigsReceiversDeleteExecute(r)
}

/*
V1InstancesAlertconfigsReceiversDelete Method for V1InstancesAlertconfigsReceiversDelete

Delete alert config receiver.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @param receiver
 @return ApiV1InstancesAlertconfigsReceiversDeleteRequest
*/
func (a *AlertConfigApiService) V1InstancesAlertconfigsReceiversDelete(ctx context.Context, instanceId string, receiver string) ApiV1InstancesAlertconfigsReceiversDeleteRequest {
	return ApiV1InstancesAlertconfigsReceiversDeleteRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
		receiver: receiver,
	}
}

// Execute executes the request
//  @return ReceiversResponse
func (a *AlertConfigApiService) V1InstancesAlertconfigsReceiversDeleteExecute(r ApiV1InstancesAlertconfigsReceiversDeleteRequest) (*ReceiversResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReceiversResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertConfigApiService.V1InstancesAlertconfigsReceiversDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertconfigs/receivers/{receiver}"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"receiver"+"}", url.PathEscape(parameterToString(r.receiver, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesAlertconfigsReceiversListRequest struct {
	ctx context.Context
	ApiService *AlertConfigApiService
	instanceId string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesAlertconfigsReceiversListRequest) Authorization(authorization string) ApiV1InstancesAlertconfigsReceiversListRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertconfigsReceiversListRequest) Execute() (*ReceiversResponse, *http.Response, error) {
	return r.ApiService.V1InstancesAlertconfigsReceiversListExecute(r)
}

/*
V1InstancesAlertconfigsReceiversList Method for V1InstancesAlertconfigsReceiversList

Get alert config receivers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @return ApiV1InstancesAlertconfigsReceiversListRequest
*/
func (a *AlertConfigApiService) V1InstancesAlertconfigsReceiversList(ctx context.Context, instanceId string) ApiV1InstancesAlertconfigsReceiversListRequest {
	return ApiV1InstancesAlertconfigsReceiversListRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return ReceiversResponse
func (a *AlertConfigApiService) V1InstancesAlertconfigsReceiversListExecute(r ApiV1InstancesAlertconfigsReceiversListRequest) (*ReceiversResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReceiversResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertConfigApiService.V1InstancesAlertconfigsReceiversList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertconfigs/receivers"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesAlertconfigsReceiversReadRequest struct {
	ctx context.Context
	ApiService *AlertConfigApiService
	instanceId string
	receiver string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesAlertconfigsReceiversReadRequest) Authorization(authorization string) ApiV1InstancesAlertconfigsReceiversReadRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertconfigsReceiversReadRequest) Execute() (*ReceiversResponseSerializerSingle, *http.Response, error) {
	return r.ApiService.V1InstancesAlertconfigsReceiversReadExecute(r)
}

/*
V1InstancesAlertconfigsReceiversRead Method for V1InstancesAlertconfigsReceiversRead

Get alert config receivers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @param receiver
 @return ApiV1InstancesAlertconfigsReceiversReadRequest
*/
func (a *AlertConfigApiService) V1InstancesAlertconfigsReceiversRead(ctx context.Context, instanceId string, receiver string) ApiV1InstancesAlertconfigsReceiversReadRequest {
	return ApiV1InstancesAlertconfigsReceiversReadRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
		receiver: receiver,
	}
}

// Execute executes the request
//  @return ReceiversResponseSerializerSingle
func (a *AlertConfigApiService) V1InstancesAlertconfigsReceiversReadExecute(r ApiV1InstancesAlertconfigsReceiversReadRequest) (*ReceiversResponseSerializerSingle, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReceiversResponseSerializerSingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertConfigApiService.V1InstancesAlertconfigsReceiversRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertconfigs/receivers/{receiver}"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"receiver"+"}", url.PathEscape(parameterToString(r.receiver, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesAlertconfigsReceiversUpdateRequest struct {
	ctx context.Context
	ApiService *AlertConfigApiService
	instanceId string
	receiver string
	authorization *string
	data *V1InstancesAlertconfigsUpdateRequestReceiversInner
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesAlertconfigsReceiversUpdateRequest) Authorization(authorization string) ApiV1InstancesAlertconfigsReceiversUpdateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertconfigsReceiversUpdateRequest) Data(data V1InstancesAlertconfigsUpdateRequestReceiversInner) ApiV1InstancesAlertconfigsReceiversUpdateRequest {
	r.data = &data
	return r
}

func (r ApiV1InstancesAlertconfigsReceiversUpdateRequest) Execute() (*ReceiversResponse, *http.Response, error) {
	return r.ApiService.V1InstancesAlertconfigsReceiversUpdateExecute(r)
}

/*
V1InstancesAlertconfigsReceiversUpdate Method for V1InstancesAlertconfigsReceiversUpdate

Update alert config receiver.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @param receiver
 @return ApiV1InstancesAlertconfigsReceiversUpdateRequest
*/
func (a *AlertConfigApiService) V1InstancesAlertconfigsReceiversUpdate(ctx context.Context, instanceId string, receiver string) ApiV1InstancesAlertconfigsReceiversUpdateRequest {
	return ApiV1InstancesAlertconfigsReceiversUpdateRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
		receiver: receiver,
	}
}

// Execute executes the request
//  @return ReceiversResponse
func (a *AlertConfigApiService) V1InstancesAlertconfigsReceiversUpdateExecute(r ApiV1InstancesAlertconfigsReceiversUpdateRequest) (*ReceiversResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReceiversResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertConfigApiService.V1InstancesAlertconfigsReceiversUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertconfigs/receivers/{receiver}"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"receiver"+"}", url.PathEscape(parameterToString(r.receiver, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesAlertconfigsRoutesCreateRequest struct {
	ctx context.Context
	ApiService *AlertConfigApiService
	instanceId string
	authorization *string
	data *V1InstancesAlertconfigsUpdateRequestRoute
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesAlertconfigsRoutesCreateRequest) Authorization(authorization string) ApiV1InstancesAlertconfigsRoutesCreateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertconfigsRoutesCreateRequest) Data(data V1InstancesAlertconfigsUpdateRequestRoute) ApiV1InstancesAlertconfigsRoutesCreateRequest {
	r.data = &data
	return r
}

func (r ApiV1InstancesAlertconfigsRoutesCreateRequest) Execute() (*RouteResponse, *http.Response, error) {
	return r.ApiService.V1InstancesAlertconfigsRoutesCreateExecute(r)
}

/*
V1InstancesAlertconfigsRoutesCreate Method for V1InstancesAlertconfigsRoutesCreate

Create alert config route in routes of route.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @return ApiV1InstancesAlertconfigsRoutesCreateRequest
*/
func (a *AlertConfigApiService) V1InstancesAlertconfigsRoutesCreate(ctx context.Context, instanceId string) ApiV1InstancesAlertconfigsRoutesCreateRequest {
	return ApiV1InstancesAlertconfigsRoutesCreateRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return RouteResponse
func (a *AlertConfigApiService) V1InstancesAlertconfigsRoutesCreateExecute(r ApiV1InstancesAlertconfigsRoutesCreateRequest) (*RouteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertConfigApiService.V1InstancesAlertconfigsRoutesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertconfigs/routes"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesAlertconfigsRoutesDeleteRequest struct {
	ctx context.Context
	ApiService *AlertConfigApiService
	instanceId string
	receiver string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesAlertconfigsRoutesDeleteRequest) Authorization(authorization string) ApiV1InstancesAlertconfigsRoutesDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertconfigsRoutesDeleteRequest) Execute() (*RouteResponse, *http.Response, error) {
	return r.ApiService.V1InstancesAlertconfigsRoutesDeleteExecute(r)
}

/*
V1InstancesAlertconfigsRoutesDelete Method for V1InstancesAlertconfigsRoutesDelete

Delete alert receiver for route.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @param receiver
 @return ApiV1InstancesAlertconfigsRoutesDeleteRequest
*/
func (a *AlertConfigApiService) V1InstancesAlertconfigsRoutesDelete(ctx context.Context, instanceId string, receiver string) ApiV1InstancesAlertconfigsRoutesDeleteRequest {
	return ApiV1InstancesAlertconfigsRoutesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
		receiver: receiver,
	}
}

// Execute executes the request
//  @return RouteResponse
func (a *AlertConfigApiService) V1InstancesAlertconfigsRoutesDeleteExecute(r ApiV1InstancesAlertconfigsRoutesDeleteRequest) (*RouteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertConfigApiService.V1InstancesAlertconfigsRoutesDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertconfigs/routes/{receiver}"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"receiver"+"}", url.PathEscape(parameterToString(r.receiver, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesAlertconfigsRoutesListRequest struct {
	ctx context.Context
	ApiService *AlertConfigApiService
	instanceId string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesAlertconfigsRoutesListRequest) Authorization(authorization string) ApiV1InstancesAlertconfigsRoutesListRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertconfigsRoutesListRequest) Execute() (*RouteResponse, *http.Response, error) {
	return r.ApiService.V1InstancesAlertconfigsRoutesListExecute(r)
}

/*
V1InstancesAlertconfigsRoutesList Method for V1InstancesAlertconfigsRoutesList

Get alert config route.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @return ApiV1InstancesAlertconfigsRoutesListRequest
*/
func (a *AlertConfigApiService) V1InstancesAlertconfigsRoutesList(ctx context.Context, instanceId string) ApiV1InstancesAlertconfigsRoutesListRequest {
	return ApiV1InstancesAlertconfigsRoutesListRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return RouteResponse
func (a *AlertConfigApiService) V1InstancesAlertconfigsRoutesListExecute(r ApiV1InstancesAlertconfigsRoutesListRequest) (*RouteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertConfigApiService.V1InstancesAlertconfigsRoutesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertconfigs/routes"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesAlertconfigsRoutesReadRequest struct {
	ctx context.Context
	ApiService *AlertConfigApiService
	instanceId string
	receiver string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesAlertconfigsRoutesReadRequest) Authorization(authorization string) ApiV1InstancesAlertconfigsRoutesReadRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertconfigsRoutesReadRequest) Execute() (*RouteResponse, *http.Response, error) {
	return r.ApiService.V1InstancesAlertconfigsRoutesReadExecute(r)
}

/*
V1InstancesAlertconfigsRoutesRead Method for V1InstancesAlertconfigsRoutesRead

Get alert receiver for route.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @param receiver
 @return ApiV1InstancesAlertconfigsRoutesReadRequest
*/
func (a *AlertConfigApiService) V1InstancesAlertconfigsRoutesRead(ctx context.Context, instanceId string, receiver string) ApiV1InstancesAlertconfigsRoutesReadRequest {
	return ApiV1InstancesAlertconfigsRoutesReadRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
		receiver: receiver,
	}
}

// Execute executes the request
//  @return RouteResponse
func (a *AlertConfigApiService) V1InstancesAlertconfigsRoutesReadExecute(r ApiV1InstancesAlertconfigsRoutesReadRequest) (*RouteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertConfigApiService.V1InstancesAlertconfigsRoutesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertconfigs/routes/{receiver}"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"receiver"+"}", url.PathEscape(parameterToString(r.receiver, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesAlertconfigsRoutesUpdateRequest struct {
	ctx context.Context
	ApiService *AlertConfigApiService
	instanceId string
	receiver string
	authorization *string
	data *V1InstancesAlertconfigsUpdateRequestRoute
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesAlertconfigsRoutesUpdateRequest) Authorization(authorization string) ApiV1InstancesAlertconfigsRoutesUpdateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertconfigsRoutesUpdateRequest) Data(data V1InstancesAlertconfigsUpdateRequestRoute) ApiV1InstancesAlertconfigsRoutesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiV1InstancesAlertconfigsRoutesUpdateRequest) Execute() (*RouteResponse, *http.Response, error) {
	return r.ApiService.V1InstancesAlertconfigsRoutesUpdateExecute(r)
}

/*
V1InstancesAlertconfigsRoutesUpdate Method for V1InstancesAlertconfigsRoutesUpdate

Update alert receiver for route.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @param receiver
 @return ApiV1InstancesAlertconfigsRoutesUpdateRequest
*/
func (a *AlertConfigApiService) V1InstancesAlertconfigsRoutesUpdate(ctx context.Context, instanceId string, receiver string) ApiV1InstancesAlertconfigsRoutesUpdateRequest {
	return ApiV1InstancesAlertconfigsRoutesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
		receiver: receiver,
	}
}

// Execute executes the request
//  @return RouteResponse
func (a *AlertConfigApiService) V1InstancesAlertconfigsRoutesUpdateExecute(r ApiV1InstancesAlertconfigsRoutesUpdateRequest) (*RouteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertConfigApiService.V1InstancesAlertconfigsRoutesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertconfigs/routes/{receiver}"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"receiver"+"}", url.PathEscape(parameterToString(r.receiver, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesAlertconfigsUpdateRequest struct {
	ctx context.Context
	ApiService *AlertConfigApiService
	instanceId string
	authorization *string
	data *V1InstancesAlertconfigsUpdateRequest
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesAlertconfigsUpdateRequest) Authorization(authorization string) ApiV1InstancesAlertconfigsUpdateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertconfigsUpdateRequest) Data(data V1InstancesAlertconfigsUpdateRequest) ApiV1InstancesAlertconfigsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiV1InstancesAlertconfigsUpdateRequest) Execute() (*PutAlert, *http.Response, error) {
	return r.ApiService.V1InstancesAlertconfigsUpdateExecute(r)
}

/*
V1InstancesAlertconfigsUpdate Method for V1InstancesAlertconfigsUpdate

Update alert config.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @return ApiV1InstancesAlertconfigsUpdateRequest
*/
func (a *AlertConfigApiService) V1InstancesAlertconfigsUpdate(ctx context.Context, instanceId string) ApiV1InstancesAlertconfigsUpdateRequest {
	return ApiV1InstancesAlertconfigsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return PutAlert
func (a *AlertConfigApiService) V1InstancesAlertconfigsUpdateExecute(r ApiV1InstancesAlertconfigsUpdateRequest) (*PutAlert, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PutAlert
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertConfigApiService.V1InstancesAlertconfigsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertconfigs"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertconfigsListRequest struct {
	ctx context.Context
	ApiService *AlertConfigApiService
	instanceId string
	projectId string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesAlertconfigsListRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertconfigsListRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertconfigsListRequest) Execute() (*GetAlert, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertconfigsListExecute(r)
}

/*
V1ProjectsInstancesAlertconfigsList Method for V1ProjectsInstancesAlertconfigsList

Get alert config.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @param projectId
 @return ApiV1ProjectsInstancesAlertconfigsListRequest
*/
func (a *AlertConfigApiService) V1ProjectsInstancesAlertconfigsList(ctx context.Context, instanceId string, projectId string) ApiV1ProjectsInstancesAlertconfigsListRequest {
	return ApiV1ProjectsInstancesAlertconfigsListRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return GetAlert
func (a *AlertConfigApiService) V1ProjectsInstancesAlertconfigsListExecute(r ApiV1ProjectsInstancesAlertconfigsListRequest) (*GetAlert, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAlert
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertConfigApiService.V1ProjectsInstancesAlertconfigsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertconfigs"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertconfigsReceiversCreateRequest struct {
	ctx context.Context
	ApiService *AlertConfigApiService
	instanceId string
	projectId string
	authorization *string
	data *V1InstancesAlertconfigsUpdateRequestReceiversInner
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesAlertconfigsReceiversCreateRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertconfigsReceiversCreateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertconfigsReceiversCreateRequest) Data(data V1InstancesAlertconfigsUpdateRequestReceiversInner) ApiV1ProjectsInstancesAlertconfigsReceiversCreateRequest {
	r.data = &data
	return r
}

func (r ApiV1ProjectsInstancesAlertconfigsReceiversCreateRequest) Execute() (*ReceiversResponse, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertconfigsReceiversCreateExecute(r)
}

/*
V1ProjectsInstancesAlertconfigsReceiversCreate Method for V1ProjectsInstancesAlertconfigsReceiversCreate

Create alert config receiver.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @param projectId
 @return ApiV1ProjectsInstancesAlertconfigsReceiversCreateRequest
*/
func (a *AlertConfigApiService) V1ProjectsInstancesAlertconfigsReceiversCreate(ctx context.Context, instanceId string, projectId string) ApiV1ProjectsInstancesAlertconfigsReceiversCreateRequest {
	return ApiV1ProjectsInstancesAlertconfigsReceiversCreateRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ReceiversResponse
func (a *AlertConfigApiService) V1ProjectsInstancesAlertconfigsReceiversCreateExecute(r ApiV1ProjectsInstancesAlertconfigsReceiversCreateRequest) (*ReceiversResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReceiversResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertConfigApiService.V1ProjectsInstancesAlertconfigsReceiversCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertconfigs/receivers"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertconfigsReceiversDeleteRequest struct {
	ctx context.Context
	ApiService *AlertConfigApiService
	instanceId string
	projectId string
	receiver string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesAlertconfigsReceiversDeleteRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertconfigsReceiversDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertconfigsReceiversDeleteRequest) Execute() (*ReceiversResponse, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertconfigsReceiversDeleteExecute(r)
}

/*
V1ProjectsInstancesAlertconfigsReceiversDelete Method for V1ProjectsInstancesAlertconfigsReceiversDelete

Delete alert config receiver.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @param projectId
 @param receiver
 @return ApiV1ProjectsInstancesAlertconfigsReceiversDeleteRequest
*/
func (a *AlertConfigApiService) V1ProjectsInstancesAlertconfigsReceiversDelete(ctx context.Context, instanceId string, projectId string, receiver string) ApiV1ProjectsInstancesAlertconfigsReceiversDeleteRequest {
	return ApiV1ProjectsInstancesAlertconfigsReceiversDeleteRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
		projectId: projectId,
		receiver: receiver,
	}
}

// Execute executes the request
//  @return ReceiversResponse
func (a *AlertConfigApiService) V1ProjectsInstancesAlertconfigsReceiversDeleteExecute(r ApiV1ProjectsInstancesAlertconfigsReceiversDeleteRequest) (*ReceiversResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReceiversResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertConfigApiService.V1ProjectsInstancesAlertconfigsReceiversDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertconfigs/receivers/{receiver}"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"receiver"+"}", url.PathEscape(parameterToString(r.receiver, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertconfigsReceiversListRequest struct {
	ctx context.Context
	ApiService *AlertConfigApiService
	instanceId string
	projectId string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesAlertconfigsReceiversListRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertconfigsReceiversListRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertconfigsReceiversListRequest) Execute() (*ReceiversResponse, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertconfigsReceiversListExecute(r)
}

/*
V1ProjectsInstancesAlertconfigsReceiversList Method for V1ProjectsInstancesAlertconfigsReceiversList

Get alert config receivers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @param projectId
 @return ApiV1ProjectsInstancesAlertconfigsReceiversListRequest
*/
func (a *AlertConfigApiService) V1ProjectsInstancesAlertconfigsReceiversList(ctx context.Context, instanceId string, projectId string) ApiV1ProjectsInstancesAlertconfigsReceiversListRequest {
	return ApiV1ProjectsInstancesAlertconfigsReceiversListRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ReceiversResponse
func (a *AlertConfigApiService) V1ProjectsInstancesAlertconfigsReceiversListExecute(r ApiV1ProjectsInstancesAlertconfigsReceiversListRequest) (*ReceiversResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReceiversResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertConfigApiService.V1ProjectsInstancesAlertconfigsReceiversList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertconfigs/receivers"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertconfigsReceiversReadRequest struct {
	ctx context.Context
	ApiService *AlertConfigApiService
	instanceId string
	projectId string
	receiver string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesAlertconfigsReceiversReadRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertconfigsReceiversReadRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertconfigsReceiversReadRequest) Execute() (*ReceiversResponseSerializerSingle, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertconfigsReceiversReadExecute(r)
}

/*
V1ProjectsInstancesAlertconfigsReceiversRead Method for V1ProjectsInstancesAlertconfigsReceiversRead

Get alert config receivers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @param projectId
 @param receiver
 @return ApiV1ProjectsInstancesAlertconfigsReceiversReadRequest
*/
func (a *AlertConfigApiService) V1ProjectsInstancesAlertconfigsReceiversRead(ctx context.Context, instanceId string, projectId string, receiver string) ApiV1ProjectsInstancesAlertconfigsReceiversReadRequest {
	return ApiV1ProjectsInstancesAlertconfigsReceiversReadRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
		projectId: projectId,
		receiver: receiver,
	}
}

// Execute executes the request
//  @return ReceiversResponseSerializerSingle
func (a *AlertConfigApiService) V1ProjectsInstancesAlertconfigsReceiversReadExecute(r ApiV1ProjectsInstancesAlertconfigsReceiversReadRequest) (*ReceiversResponseSerializerSingle, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReceiversResponseSerializerSingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertConfigApiService.V1ProjectsInstancesAlertconfigsReceiversRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertconfigs/receivers/{receiver}"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"receiver"+"}", url.PathEscape(parameterToString(r.receiver, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertconfigsReceiversUpdateRequest struct {
	ctx context.Context
	ApiService *AlertConfigApiService
	instanceId string
	projectId string
	receiver string
	authorization *string
	data *V1InstancesAlertconfigsUpdateRequestReceiversInner
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesAlertconfigsReceiversUpdateRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertconfigsReceiversUpdateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertconfigsReceiversUpdateRequest) Data(data V1InstancesAlertconfigsUpdateRequestReceiversInner) ApiV1ProjectsInstancesAlertconfigsReceiversUpdateRequest {
	r.data = &data
	return r
}

func (r ApiV1ProjectsInstancesAlertconfigsReceiversUpdateRequest) Execute() (*ReceiversResponse, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertconfigsReceiversUpdateExecute(r)
}

/*
V1ProjectsInstancesAlertconfigsReceiversUpdate Method for V1ProjectsInstancesAlertconfigsReceiversUpdate

Update alert config receiver.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @param projectId
 @param receiver
 @return ApiV1ProjectsInstancesAlertconfigsReceiversUpdateRequest
*/
func (a *AlertConfigApiService) V1ProjectsInstancesAlertconfigsReceiversUpdate(ctx context.Context, instanceId string, projectId string, receiver string) ApiV1ProjectsInstancesAlertconfigsReceiversUpdateRequest {
	return ApiV1ProjectsInstancesAlertconfigsReceiversUpdateRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
		projectId: projectId,
		receiver: receiver,
	}
}

// Execute executes the request
//  @return ReceiversResponse
func (a *AlertConfigApiService) V1ProjectsInstancesAlertconfigsReceiversUpdateExecute(r ApiV1ProjectsInstancesAlertconfigsReceiversUpdateRequest) (*ReceiversResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReceiversResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertConfigApiService.V1ProjectsInstancesAlertconfigsReceiversUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertconfigs/receivers/{receiver}"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"receiver"+"}", url.PathEscape(parameterToString(r.receiver, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertconfigsRoutesCreateRequest struct {
	ctx context.Context
	ApiService *AlertConfigApiService
	instanceId string
	projectId string
	authorization *string
	data *V1InstancesAlertconfigsUpdateRequestRoute
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesAlertconfigsRoutesCreateRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertconfigsRoutesCreateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertconfigsRoutesCreateRequest) Data(data V1InstancesAlertconfigsUpdateRequestRoute) ApiV1ProjectsInstancesAlertconfigsRoutesCreateRequest {
	r.data = &data
	return r
}

func (r ApiV1ProjectsInstancesAlertconfigsRoutesCreateRequest) Execute() (*RouteResponse, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertconfigsRoutesCreateExecute(r)
}

/*
V1ProjectsInstancesAlertconfigsRoutesCreate Method for V1ProjectsInstancesAlertconfigsRoutesCreate

Create alert config route in routes of route.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @param projectId
 @return ApiV1ProjectsInstancesAlertconfigsRoutesCreateRequest
*/
func (a *AlertConfigApiService) V1ProjectsInstancesAlertconfigsRoutesCreate(ctx context.Context, instanceId string, projectId string) ApiV1ProjectsInstancesAlertconfigsRoutesCreateRequest {
	return ApiV1ProjectsInstancesAlertconfigsRoutesCreateRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return RouteResponse
func (a *AlertConfigApiService) V1ProjectsInstancesAlertconfigsRoutesCreateExecute(r ApiV1ProjectsInstancesAlertconfigsRoutesCreateRequest) (*RouteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertConfigApiService.V1ProjectsInstancesAlertconfigsRoutesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertconfigs/routes"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertconfigsRoutesDeleteRequest struct {
	ctx context.Context
	ApiService *AlertConfigApiService
	instanceId string
	projectId string
	receiver string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesAlertconfigsRoutesDeleteRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertconfigsRoutesDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertconfigsRoutesDeleteRequest) Execute() (*RouteResponse, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertconfigsRoutesDeleteExecute(r)
}

/*
V1ProjectsInstancesAlertconfigsRoutesDelete Method for V1ProjectsInstancesAlertconfigsRoutesDelete

Delete alert receiver for route.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @param projectId
 @param receiver
 @return ApiV1ProjectsInstancesAlertconfigsRoutesDeleteRequest
*/
func (a *AlertConfigApiService) V1ProjectsInstancesAlertconfigsRoutesDelete(ctx context.Context, instanceId string, projectId string, receiver string) ApiV1ProjectsInstancesAlertconfigsRoutesDeleteRequest {
	return ApiV1ProjectsInstancesAlertconfigsRoutesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
		projectId: projectId,
		receiver: receiver,
	}
}

// Execute executes the request
//  @return RouteResponse
func (a *AlertConfigApiService) V1ProjectsInstancesAlertconfigsRoutesDeleteExecute(r ApiV1ProjectsInstancesAlertconfigsRoutesDeleteRequest) (*RouteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertConfigApiService.V1ProjectsInstancesAlertconfigsRoutesDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertconfigs/routes/{receiver}"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"receiver"+"}", url.PathEscape(parameterToString(r.receiver, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertconfigsRoutesListRequest struct {
	ctx context.Context
	ApiService *AlertConfigApiService
	instanceId string
	projectId string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesAlertconfigsRoutesListRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertconfigsRoutesListRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertconfigsRoutesListRequest) Execute() (*RouteResponse, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertconfigsRoutesListExecute(r)
}

/*
V1ProjectsInstancesAlertconfigsRoutesList Method for V1ProjectsInstancesAlertconfigsRoutesList

Get alert config route.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @param projectId
 @return ApiV1ProjectsInstancesAlertconfigsRoutesListRequest
*/
func (a *AlertConfigApiService) V1ProjectsInstancesAlertconfigsRoutesList(ctx context.Context, instanceId string, projectId string) ApiV1ProjectsInstancesAlertconfigsRoutesListRequest {
	return ApiV1ProjectsInstancesAlertconfigsRoutesListRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return RouteResponse
func (a *AlertConfigApiService) V1ProjectsInstancesAlertconfigsRoutesListExecute(r ApiV1ProjectsInstancesAlertconfigsRoutesListRequest) (*RouteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertConfigApiService.V1ProjectsInstancesAlertconfigsRoutesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertconfigs/routes"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertconfigsRoutesReadRequest struct {
	ctx context.Context
	ApiService *AlertConfigApiService
	instanceId string
	projectId string
	receiver string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesAlertconfigsRoutesReadRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertconfigsRoutesReadRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertconfigsRoutesReadRequest) Execute() (*RouteResponse, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertconfigsRoutesReadExecute(r)
}

/*
V1ProjectsInstancesAlertconfigsRoutesRead Method for V1ProjectsInstancesAlertconfigsRoutesRead

Get alert receiver for route.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @param projectId
 @param receiver
 @return ApiV1ProjectsInstancesAlertconfigsRoutesReadRequest
*/
func (a *AlertConfigApiService) V1ProjectsInstancesAlertconfigsRoutesRead(ctx context.Context, instanceId string, projectId string, receiver string) ApiV1ProjectsInstancesAlertconfigsRoutesReadRequest {
	return ApiV1ProjectsInstancesAlertconfigsRoutesReadRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
		projectId: projectId,
		receiver: receiver,
	}
}

// Execute executes the request
//  @return RouteResponse
func (a *AlertConfigApiService) V1ProjectsInstancesAlertconfigsRoutesReadExecute(r ApiV1ProjectsInstancesAlertconfigsRoutesReadRequest) (*RouteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertConfigApiService.V1ProjectsInstancesAlertconfigsRoutesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertconfigs/routes/{receiver}"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"receiver"+"}", url.PathEscape(parameterToString(r.receiver, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertconfigsRoutesUpdateRequest struct {
	ctx context.Context
	ApiService *AlertConfigApiService
	instanceId string
	projectId string
	receiver string
	authorization *string
	data *V1InstancesAlertconfigsUpdateRequestRoute
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesAlertconfigsRoutesUpdateRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertconfigsRoutesUpdateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertconfigsRoutesUpdateRequest) Data(data V1InstancesAlertconfigsUpdateRequestRoute) ApiV1ProjectsInstancesAlertconfigsRoutesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiV1ProjectsInstancesAlertconfigsRoutesUpdateRequest) Execute() (*RouteResponse, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertconfigsRoutesUpdateExecute(r)
}

/*
V1ProjectsInstancesAlertconfigsRoutesUpdate Method for V1ProjectsInstancesAlertconfigsRoutesUpdate

Update alert receiver for route.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @param projectId
 @param receiver
 @return ApiV1ProjectsInstancesAlertconfigsRoutesUpdateRequest
*/
func (a *AlertConfigApiService) V1ProjectsInstancesAlertconfigsRoutesUpdate(ctx context.Context, instanceId string, projectId string, receiver string) ApiV1ProjectsInstancesAlertconfigsRoutesUpdateRequest {
	return ApiV1ProjectsInstancesAlertconfigsRoutesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
		projectId: projectId,
		receiver: receiver,
	}
}

// Execute executes the request
//  @return RouteResponse
func (a *AlertConfigApiService) V1ProjectsInstancesAlertconfigsRoutesUpdateExecute(r ApiV1ProjectsInstancesAlertconfigsRoutesUpdateRequest) (*RouteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertConfigApiService.V1ProjectsInstancesAlertconfigsRoutesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertconfigs/routes/{receiver}"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"receiver"+"}", url.PathEscape(parameterToString(r.receiver, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertconfigsUpdateRequest struct {
	ctx context.Context
	ApiService *AlertConfigApiService
	instanceId string
	projectId string
	authorization *string
	data *V1InstancesAlertconfigsUpdateRequest
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesAlertconfigsUpdateRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertconfigsUpdateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertconfigsUpdateRequest) Data(data V1InstancesAlertconfigsUpdateRequest) ApiV1ProjectsInstancesAlertconfigsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiV1ProjectsInstancesAlertconfigsUpdateRequest) Execute() (*PutAlert, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertconfigsUpdateExecute(r)
}

/*
V1ProjectsInstancesAlertconfigsUpdate Method for V1ProjectsInstancesAlertconfigsUpdate

Update alert config.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param instanceId
 @param projectId
 @return ApiV1ProjectsInstancesAlertconfigsUpdateRequest
*/
func (a *AlertConfigApiService) V1ProjectsInstancesAlertconfigsUpdate(ctx context.Context, instanceId string, projectId string) ApiV1ProjectsInstancesAlertconfigsUpdateRequest {
	return ApiV1ProjectsInstancesAlertconfigsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		instanceId: instanceId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PutAlert
func (a *AlertConfigApiService) V1ProjectsInstancesAlertconfigsUpdateExecute(r ApiV1ProjectsInstancesAlertconfigsUpdateRequest) (*PutAlert, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PutAlert
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertConfigApiService.V1ProjectsInstancesAlertconfigsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertconfigs"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
