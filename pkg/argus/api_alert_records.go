/*
STACKIT Argus API

API endpoints for Argus on STACKIT

API version: v1
Contact: stackit-argus@mail.schwarz
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package argus

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// AlertRecordsApiService AlertRecordsApi service
type AlertRecordsApiService service

type ApiV1InstancesAlertgroupsRecordsCreateRequest struct {
	ctx           context.Context
	ApiService    *AlertRecordsApiService
	groupName     string
	instanceId    string
	authorization *string
	data          *V1InstancesAlertgroupsRecordsCreateRequest
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesAlertgroupsRecordsCreateRequest) Authorization(authorization string) ApiV1InstancesAlertgroupsRecordsCreateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertgroupsRecordsCreateRequest) Data(data V1InstancesAlertgroupsRecordsCreateRequest) ApiV1InstancesAlertgroupsRecordsCreateRequest {
	r.data = &data
	return r
}

func (r ApiV1InstancesAlertgroupsRecordsCreateRequest) Execute() (*AlertRecordsResponse, *http.Response, error) {
	return r.ApiService.V1InstancesAlertgroupsRecordsCreateExecute(r)
}

/*
V1InstancesAlertgroupsRecordsCreate Method for V1InstancesAlertgroupsRecordsCreate

Create alert record.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupName
	@param instanceId
	@return ApiV1InstancesAlertgroupsRecordsCreateRequest
*/
func (a *AlertRecordsApiService) V1InstancesAlertgroupsRecordsCreate(ctx context.Context, groupName string, instanceId string) ApiV1InstancesAlertgroupsRecordsCreateRequest {
	return ApiV1InstancesAlertgroupsRecordsCreateRequest{
		ApiService: a,
		ctx:        ctx,
		groupName:  groupName,
		instanceId: instanceId,
	}
}

// Execute executes the request
//
//	@return AlertRecordsResponse
func (a *AlertRecordsApiService) V1InstancesAlertgroupsRecordsCreateExecute(r ApiV1InstancesAlertgroupsRecordsCreateRequest) (*AlertRecordsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AlertRecordsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRecordsApiService.V1InstancesAlertgroupsRecordsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertgroups/{groupName}/records"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesAlertgroupsRecordsDeleteRequest struct {
	ctx           context.Context
	ApiService    *AlertRecordsApiService
	groupName     string
	instanceId    string
	authorization *string
	alertRecord   *[]string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesAlertgroupsRecordsDeleteRequest) Authorization(authorization string) ApiV1InstancesAlertgroupsRecordsDeleteRequest {
	r.authorization = &authorization
	return r
}

// Name of the records that should be deleted
func (r ApiV1InstancesAlertgroupsRecordsDeleteRequest) AlertRecord(alertRecord []string) ApiV1InstancesAlertgroupsRecordsDeleteRequest {
	r.alertRecord = &alertRecord
	return r
}

func (r ApiV1InstancesAlertgroupsRecordsDeleteRequest) Execute() (*AlertRecordsResponse, *http.Response, error) {
	return r.ApiService.V1InstancesAlertgroupsRecordsDeleteExecute(r)
}

/*
V1InstancesAlertgroupsRecordsDelete Method for V1InstancesAlertgroupsRecordsDelete

Delete alert records.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupName
	@param instanceId
	@return ApiV1InstancesAlertgroupsRecordsDeleteRequest
*/
func (a *AlertRecordsApiService) V1InstancesAlertgroupsRecordsDelete(ctx context.Context, groupName string, instanceId string) ApiV1InstancesAlertgroupsRecordsDeleteRequest {
	return ApiV1InstancesAlertgroupsRecordsDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		groupName:  groupName,
		instanceId: instanceId,
	}
}

// Execute executes the request
//
//	@return AlertRecordsResponse
func (a *AlertRecordsApiService) V1InstancesAlertgroupsRecordsDeleteExecute(r ApiV1InstancesAlertgroupsRecordsDeleteRequest) (*AlertRecordsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AlertRecordsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRecordsApiService.V1InstancesAlertgroupsRecordsDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertgroups/{groupName}/records"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.alertRecord == nil {
		return localVarReturnValue, nil, reportError("alertRecord is required and must be specified")
	}

	localVarQueryParams.Add("alertRecord", parameterToString(*r.alertRecord, "csv"))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesAlertgroupsRecordsDelete_0Request struct {
	ctx           context.Context
	ApiService    *AlertRecordsApiService
	alertRecord   string
	groupName     string
	instanceId    string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesAlertgroupsRecordsDelete_0Request) Authorization(authorization string) ApiV1InstancesAlertgroupsRecordsDelete_0Request {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertgroupsRecordsDelete_0Request) Execute() (*AlertRecordsResponse, *http.Response, error) {
	return r.ApiService.V1InstancesAlertgroupsRecordsDelete_1Execute(r)
}

/*
V1InstancesAlertgroupsRecordsDelete_0 Method for V1InstancesAlertgroupsRecordsDelete_0

Delete alert record.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param alertRecord
	@param groupName
	@param instanceId
	@return ApiV1InstancesAlertgroupsRecordsDelete_0Request
*/
func (a *AlertRecordsApiService) V1InstancesAlertgroupsRecordsDelete_1(ctx context.Context, alertRecord string, groupName string, instanceId string) ApiV1InstancesAlertgroupsRecordsDelete_0Request {
	return ApiV1InstancesAlertgroupsRecordsDelete_0Request{
		ApiService:  a,
		ctx:         ctx,
		alertRecord: alertRecord,
		groupName:   groupName,
		instanceId:  instanceId,
	}
}

// Execute executes the request
//
//	@return AlertRecordsResponse
func (a *AlertRecordsApiService) V1InstancesAlertgroupsRecordsDelete_1Execute(r ApiV1InstancesAlertgroupsRecordsDelete_0Request) (*AlertRecordsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AlertRecordsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRecordsApiService.V1InstancesAlertgroupsRecordsDelete_1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertgroups/{groupName}/records/{alertRecord}"
	localVarPath = strings.Replace(localVarPath, "{"+"alertRecord"+"}", url.PathEscape(parameterToString(r.alertRecord, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesAlertgroupsRecordsListRequest struct {
	ctx           context.Context
	ApiService    *AlertRecordsApiService
	groupName     string
	instanceId    string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesAlertgroupsRecordsListRequest) Authorization(authorization string) ApiV1InstancesAlertgroupsRecordsListRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertgroupsRecordsListRequest) Execute() (*AlertRecordsResponse, *http.Response, error) {
	return r.ApiService.V1InstancesAlertgroupsRecordsListExecute(r)
}

/*
V1InstancesAlertgroupsRecordsList Method for V1InstancesAlertgroupsRecordsList

Get alert records.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupName
	@param instanceId
	@return ApiV1InstancesAlertgroupsRecordsListRequest
*/
func (a *AlertRecordsApiService) V1InstancesAlertgroupsRecordsList(ctx context.Context, groupName string, instanceId string) ApiV1InstancesAlertgroupsRecordsListRequest {
	return ApiV1InstancesAlertgroupsRecordsListRequest{
		ApiService: a,
		ctx:        ctx,
		groupName:  groupName,
		instanceId: instanceId,
	}
}

// Execute executes the request
//
//	@return AlertRecordsResponse
func (a *AlertRecordsApiService) V1InstancesAlertgroupsRecordsListExecute(r ApiV1InstancesAlertgroupsRecordsListRequest) (*AlertRecordsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AlertRecordsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRecordsApiService.V1InstancesAlertgroupsRecordsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertgroups/{groupName}/records"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesAlertgroupsRecordsPartialUpdateRequest struct {
	ctx           context.Context
	ApiService    *AlertRecordsApiService
	groupName     string
	instanceId    string
	authorization *string
	data          *[]V1InstancesAlertgroupsRecordsCreateRequest
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesAlertgroupsRecordsPartialUpdateRequest) Authorization(authorization string) ApiV1InstancesAlertgroupsRecordsPartialUpdateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertgroupsRecordsPartialUpdateRequest) Data(data []V1InstancesAlertgroupsRecordsCreateRequest) ApiV1InstancesAlertgroupsRecordsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiV1InstancesAlertgroupsRecordsPartialUpdateRequest) Execute() (*AlertRecordsResponse, *http.Response, error) {
	return r.ApiService.V1InstancesAlertgroupsRecordsPartialUpdateExecute(r)
}

/*
V1InstancesAlertgroupsRecordsPartialUpdate Method for V1InstancesAlertgroupsRecordsPartialUpdate

Patch alert records.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupName
	@param instanceId
	@return ApiV1InstancesAlertgroupsRecordsPartialUpdateRequest
*/
func (a *AlertRecordsApiService) V1InstancesAlertgroupsRecordsPartialUpdate(ctx context.Context, groupName string, instanceId string) ApiV1InstancesAlertgroupsRecordsPartialUpdateRequest {
	return ApiV1InstancesAlertgroupsRecordsPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		groupName:  groupName,
		instanceId: instanceId,
	}
}

// Execute executes the request
//
//	@return AlertRecordsResponse
func (a *AlertRecordsApiService) V1InstancesAlertgroupsRecordsPartialUpdateExecute(r ApiV1InstancesAlertgroupsRecordsPartialUpdateRequest) (*AlertRecordsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AlertRecordsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRecordsApiService.V1InstancesAlertgroupsRecordsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertgroups/{groupName}/records"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesAlertgroupsRecordsReadRequest struct {
	ctx           context.Context
	ApiService    *AlertRecordsApiService
	alertRecord   string
	groupName     string
	instanceId    string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesAlertgroupsRecordsReadRequest) Authorization(authorization string) ApiV1InstancesAlertgroupsRecordsReadRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertgroupsRecordsReadRequest) Execute() (*AlertRecordResponse, *http.Response, error) {
	return r.ApiService.V1InstancesAlertgroupsRecordsReadExecute(r)
}

/*
V1InstancesAlertgroupsRecordsRead Method for V1InstancesAlertgroupsRecordsRead

Get alert record.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param alertRecord
	@param groupName
	@param instanceId
	@return ApiV1InstancesAlertgroupsRecordsReadRequest
*/
func (a *AlertRecordsApiService) V1InstancesAlertgroupsRecordsRead(ctx context.Context, alertRecord string, groupName string, instanceId string) ApiV1InstancesAlertgroupsRecordsReadRequest {
	return ApiV1InstancesAlertgroupsRecordsReadRequest{
		ApiService:  a,
		ctx:         ctx,
		alertRecord: alertRecord,
		groupName:   groupName,
		instanceId:  instanceId,
	}
}

// Execute executes the request
//
//	@return AlertRecordResponse
func (a *AlertRecordsApiService) V1InstancesAlertgroupsRecordsReadExecute(r ApiV1InstancesAlertgroupsRecordsReadRequest) (*AlertRecordResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AlertRecordResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRecordsApiService.V1InstancesAlertgroupsRecordsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertgroups/{groupName}/records/{alertRecord}"
	localVarPath = strings.Replace(localVarPath, "{"+"alertRecord"+"}", url.PathEscape(parameterToString(r.alertRecord, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesAlertgroupsRecordsUpdateRequest struct {
	ctx           context.Context
	ApiService    *AlertRecordsApiService
	alertRecord   string
	groupName     string
	instanceId    string
	authorization *string
	data          *V1InstancesAlertgroupsRecordsUpdateRequest
}

// Accepts technical credentials and api gateway access.
func (r ApiV1InstancesAlertgroupsRecordsUpdateRequest) Authorization(authorization string) ApiV1InstancesAlertgroupsRecordsUpdateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertgroupsRecordsUpdateRequest) Data(data V1InstancesAlertgroupsRecordsUpdateRequest) ApiV1InstancesAlertgroupsRecordsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiV1InstancesAlertgroupsRecordsUpdateRequest) Execute() (*AlertRecordsResponse, *http.Response, error) {
	return r.ApiService.V1InstancesAlertgroupsRecordsUpdateExecute(r)
}

/*
V1InstancesAlertgroupsRecordsUpdate Method for V1InstancesAlertgroupsRecordsUpdate

Update alert record.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param alertRecord
	@param groupName
	@param instanceId
	@return ApiV1InstancesAlertgroupsRecordsUpdateRequest
*/
func (a *AlertRecordsApiService) V1InstancesAlertgroupsRecordsUpdate(ctx context.Context, alertRecord string, groupName string, instanceId string) ApiV1InstancesAlertgroupsRecordsUpdateRequest {
	return ApiV1InstancesAlertgroupsRecordsUpdateRequest{
		ApiService:  a,
		ctx:         ctx,
		alertRecord: alertRecord,
		groupName:   groupName,
		instanceId:  instanceId,
	}
}

// Execute executes the request
//
//	@return AlertRecordsResponse
func (a *AlertRecordsApiService) V1InstancesAlertgroupsRecordsUpdateExecute(r ApiV1InstancesAlertgroupsRecordsUpdateRequest) (*AlertRecordsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AlertRecordsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRecordsApiService.V1InstancesAlertgroupsRecordsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertgroups/{groupName}/records/{alertRecord}"
	localVarPath = strings.Replace(localVarPath, "{"+"alertRecord"+"}", url.PathEscape(parameterToString(r.alertRecord, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertgroupsRecordsCreateRequest struct {
	ctx           context.Context
	ApiService    *AlertRecordsApiService
	groupName     string
	instanceId    string
	projectId     string
	authorization *string
	data          *V1InstancesAlertgroupsRecordsCreateRequest
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesAlertgroupsRecordsCreateRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertgroupsRecordsCreateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsRecordsCreateRequest) Data(data V1InstancesAlertgroupsRecordsCreateRequest) ApiV1ProjectsInstancesAlertgroupsRecordsCreateRequest {
	r.data = &data
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsRecordsCreateRequest) Execute() (*AlertRecordsResponse, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertgroupsRecordsCreateExecute(r)
}

/*
V1ProjectsInstancesAlertgroupsRecordsCreate Method for V1ProjectsInstancesAlertgroupsRecordsCreate

Create alert record.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupName
	@param instanceId
	@param projectId
	@return ApiV1ProjectsInstancesAlertgroupsRecordsCreateRequest
*/
func (a *AlertRecordsApiService) V1ProjectsInstancesAlertgroupsRecordsCreate(ctx context.Context, groupName string, instanceId string, projectId string) ApiV1ProjectsInstancesAlertgroupsRecordsCreateRequest {
	return ApiV1ProjectsInstancesAlertgroupsRecordsCreateRequest{
		ApiService: a,
		ctx:        ctx,
		groupName:  groupName,
		instanceId: instanceId,
		projectId:  projectId,
	}
}

// Execute executes the request
//
//	@return AlertRecordsResponse
func (a *AlertRecordsApiService) V1ProjectsInstancesAlertgroupsRecordsCreateExecute(r ApiV1ProjectsInstancesAlertgroupsRecordsCreateRequest) (*AlertRecordsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AlertRecordsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRecordsApiService.V1ProjectsInstancesAlertgroupsRecordsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertgroups/{groupName}/records"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertgroupsRecordsDeleteRequest struct {
	ctx           context.Context
	ApiService    *AlertRecordsApiService
	groupName     string
	instanceId    string
	projectId     string
	authorization *string
	alertRecord   *[]string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesAlertgroupsRecordsDeleteRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertgroupsRecordsDeleteRequest {
	r.authorization = &authorization
	return r
}

// Name of the records that should be deleted
func (r ApiV1ProjectsInstancesAlertgroupsRecordsDeleteRequest) AlertRecord(alertRecord []string) ApiV1ProjectsInstancesAlertgroupsRecordsDeleteRequest {
	r.alertRecord = &alertRecord
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsRecordsDeleteRequest) Execute() (*AlertRecordsResponse, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertgroupsRecordsDeleteExecute(r)
}

/*
V1ProjectsInstancesAlertgroupsRecordsDelete Method for V1ProjectsInstancesAlertgroupsRecordsDelete

Delete alert records.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupName
	@param instanceId
	@param projectId
	@return ApiV1ProjectsInstancesAlertgroupsRecordsDeleteRequest
*/
func (a *AlertRecordsApiService) V1ProjectsInstancesAlertgroupsRecordsDelete(ctx context.Context, groupName string, instanceId string, projectId string) ApiV1ProjectsInstancesAlertgroupsRecordsDeleteRequest {
	return ApiV1ProjectsInstancesAlertgroupsRecordsDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		groupName:  groupName,
		instanceId: instanceId,
		projectId:  projectId,
	}
}

// Execute executes the request
//
//	@return AlertRecordsResponse
func (a *AlertRecordsApiService) V1ProjectsInstancesAlertgroupsRecordsDeleteExecute(r ApiV1ProjectsInstancesAlertgroupsRecordsDeleteRequest) (*AlertRecordsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AlertRecordsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRecordsApiService.V1ProjectsInstancesAlertgroupsRecordsDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertgroups/{groupName}/records"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.alertRecord == nil {
		return localVarReturnValue, nil, reportError("alertRecord is required and must be specified")
	}

	localVarQueryParams.Add("alertRecord", parameterToString(*r.alertRecord, "csv"))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertgroupsRecordsDelete_0Request struct {
	ctx           context.Context
	ApiService    *AlertRecordsApiService
	alertRecord   string
	groupName     string
	instanceId    string
	projectId     string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesAlertgroupsRecordsDelete_0Request) Authorization(authorization string) ApiV1ProjectsInstancesAlertgroupsRecordsDelete_0Request {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsRecordsDelete_0Request) Execute() (*AlertRecordsResponse, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertgroupsRecordsDelete_2Execute(r)
}

/*
V1ProjectsInstancesAlertgroupsRecordsDelete_0 Method for V1ProjectsInstancesAlertgroupsRecordsDelete_0

Delete alert record.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param alertRecord
	@param groupName
	@param instanceId
	@param projectId
	@return ApiV1ProjectsInstancesAlertgroupsRecordsDelete_0Request
*/
func (a *AlertRecordsApiService) V1ProjectsInstancesAlertgroupsRecordsDelete_2(ctx context.Context, alertRecord string, groupName string, instanceId string, projectId string) ApiV1ProjectsInstancesAlertgroupsRecordsDelete_0Request {
	return ApiV1ProjectsInstancesAlertgroupsRecordsDelete_0Request{
		ApiService:  a,
		ctx:         ctx,
		alertRecord: alertRecord,
		groupName:   groupName,
		instanceId:  instanceId,
		projectId:   projectId,
	}
}

// Execute executes the request
//
//	@return AlertRecordsResponse
func (a *AlertRecordsApiService) V1ProjectsInstancesAlertgroupsRecordsDelete_2Execute(r ApiV1ProjectsInstancesAlertgroupsRecordsDelete_0Request) (*AlertRecordsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AlertRecordsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRecordsApiService.V1ProjectsInstancesAlertgroupsRecordsDelete_2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertgroups/{groupName}/records/{alertRecord}"
	localVarPath = strings.Replace(localVarPath, "{"+"alertRecord"+"}", url.PathEscape(parameterToString(r.alertRecord, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertgroupsRecordsListRequest struct {
	ctx           context.Context
	ApiService    *AlertRecordsApiService
	groupName     string
	instanceId    string
	projectId     string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesAlertgroupsRecordsListRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertgroupsRecordsListRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsRecordsListRequest) Execute() (*AlertRecordsResponse, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertgroupsRecordsListExecute(r)
}

/*
V1ProjectsInstancesAlertgroupsRecordsList Method for V1ProjectsInstancesAlertgroupsRecordsList

Get alert records.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupName
	@param instanceId
	@param projectId
	@return ApiV1ProjectsInstancesAlertgroupsRecordsListRequest
*/
func (a *AlertRecordsApiService) V1ProjectsInstancesAlertgroupsRecordsList(ctx context.Context, groupName string, instanceId string, projectId string) ApiV1ProjectsInstancesAlertgroupsRecordsListRequest {
	return ApiV1ProjectsInstancesAlertgroupsRecordsListRequest{
		ApiService: a,
		ctx:        ctx,
		groupName:  groupName,
		instanceId: instanceId,
		projectId:  projectId,
	}
}

// Execute executes the request
//
//	@return AlertRecordsResponse
func (a *AlertRecordsApiService) V1ProjectsInstancesAlertgroupsRecordsListExecute(r ApiV1ProjectsInstancesAlertgroupsRecordsListRequest) (*AlertRecordsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AlertRecordsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRecordsApiService.V1ProjectsInstancesAlertgroupsRecordsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertgroups/{groupName}/records"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertgroupsRecordsPartialUpdateRequest struct {
	ctx           context.Context
	ApiService    *AlertRecordsApiService
	groupName     string
	instanceId    string
	projectId     string
	authorization *string
	data          *[]V1InstancesAlertgroupsRecordsCreateRequest
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesAlertgroupsRecordsPartialUpdateRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertgroupsRecordsPartialUpdateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsRecordsPartialUpdateRequest) Data(data []V1InstancesAlertgroupsRecordsCreateRequest) ApiV1ProjectsInstancesAlertgroupsRecordsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsRecordsPartialUpdateRequest) Execute() (*AlertRecordsResponse, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertgroupsRecordsPartialUpdateExecute(r)
}

/*
V1ProjectsInstancesAlertgroupsRecordsPartialUpdate Method for V1ProjectsInstancesAlertgroupsRecordsPartialUpdate

Patch alert records.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupName
	@param instanceId
	@param projectId
	@return ApiV1ProjectsInstancesAlertgroupsRecordsPartialUpdateRequest
*/
func (a *AlertRecordsApiService) V1ProjectsInstancesAlertgroupsRecordsPartialUpdate(ctx context.Context, groupName string, instanceId string, projectId string) ApiV1ProjectsInstancesAlertgroupsRecordsPartialUpdateRequest {
	return ApiV1ProjectsInstancesAlertgroupsRecordsPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		groupName:  groupName,
		instanceId: instanceId,
		projectId:  projectId,
	}
}

// Execute executes the request
//
//	@return AlertRecordsResponse
func (a *AlertRecordsApiService) V1ProjectsInstancesAlertgroupsRecordsPartialUpdateExecute(r ApiV1ProjectsInstancesAlertgroupsRecordsPartialUpdateRequest) (*AlertRecordsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AlertRecordsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRecordsApiService.V1ProjectsInstancesAlertgroupsRecordsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertgroups/{groupName}/records"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertgroupsRecordsReadRequest struct {
	ctx           context.Context
	ApiService    *AlertRecordsApiService
	alertRecord   string
	groupName     string
	instanceId    string
	projectId     string
	authorization *string
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesAlertgroupsRecordsReadRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertgroupsRecordsReadRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsRecordsReadRequest) Execute() (*AlertRecordResponse, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertgroupsRecordsReadExecute(r)
}

/*
V1ProjectsInstancesAlertgroupsRecordsRead Method for V1ProjectsInstancesAlertgroupsRecordsRead

Get alert record.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param alertRecord
	@param groupName
	@param instanceId
	@param projectId
	@return ApiV1ProjectsInstancesAlertgroupsRecordsReadRequest
*/
func (a *AlertRecordsApiService) V1ProjectsInstancesAlertgroupsRecordsRead(ctx context.Context, alertRecord string, groupName string, instanceId string, projectId string) ApiV1ProjectsInstancesAlertgroupsRecordsReadRequest {
	return ApiV1ProjectsInstancesAlertgroupsRecordsReadRequest{
		ApiService:  a,
		ctx:         ctx,
		alertRecord: alertRecord,
		groupName:   groupName,
		instanceId:  instanceId,
		projectId:   projectId,
	}
}

// Execute executes the request
//
//	@return AlertRecordResponse
func (a *AlertRecordsApiService) V1ProjectsInstancesAlertgroupsRecordsReadExecute(r ApiV1ProjectsInstancesAlertgroupsRecordsReadRequest) (*AlertRecordResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AlertRecordResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRecordsApiService.V1ProjectsInstancesAlertgroupsRecordsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertgroups/{groupName}/records/{alertRecord}"
	localVarPath = strings.Replace(localVarPath, "{"+"alertRecord"+"}", url.PathEscape(parameterToString(r.alertRecord, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertgroupsRecordsUpdateRequest struct {
	ctx           context.Context
	ApiService    *AlertRecordsApiService
	alertRecord   string
	groupName     string
	instanceId    string
	projectId     string
	authorization *string
	data          *V1InstancesAlertgroupsRecordsUpdateRequest
}

// Accepts technical credentials and api gateway access.
func (r ApiV1ProjectsInstancesAlertgroupsRecordsUpdateRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertgroupsRecordsUpdateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsRecordsUpdateRequest) Data(data V1InstancesAlertgroupsRecordsUpdateRequest) ApiV1ProjectsInstancesAlertgroupsRecordsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsRecordsUpdateRequest) Execute() (*AlertRecordsResponse, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertgroupsRecordsUpdateExecute(r)
}

/*
V1ProjectsInstancesAlertgroupsRecordsUpdate Method for V1ProjectsInstancesAlertgroupsRecordsUpdate

Update alert record.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param alertRecord
	@param groupName
	@param instanceId
	@param projectId
	@return ApiV1ProjectsInstancesAlertgroupsRecordsUpdateRequest
*/
func (a *AlertRecordsApiService) V1ProjectsInstancesAlertgroupsRecordsUpdate(ctx context.Context, alertRecord string, groupName string, instanceId string, projectId string) ApiV1ProjectsInstancesAlertgroupsRecordsUpdateRequest {
	return ApiV1ProjectsInstancesAlertgroupsRecordsUpdateRequest{
		ApiService:  a,
		ctx:         ctx,
		alertRecord: alertRecord,
		groupName:   groupName,
		instanceId:  instanceId,
		projectId:   projectId,
	}
}

// Execute executes the request
//
//	@return AlertRecordsResponse
func (a *AlertRecordsApiService) V1ProjectsInstancesAlertgroupsRecordsUpdateExecute(r ApiV1ProjectsInstancesAlertgroupsRecordsUpdateRequest) (*AlertRecordsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AlertRecordsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRecordsApiService.V1ProjectsInstancesAlertgroupsRecordsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertgroups/{groupName}/records/{alertRecord}"
	localVarPath = strings.Replace(localVarPath, "{"+"alertRecord"+"}", url.PathEscape(parameterToString(r.alertRecord, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
