/*
STACKIT Argus API

API endpoints for Argus on STACKIT

API version: 1.0
Contact: patrick.koss@mail.schwarz
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package argus

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// AlertRulesApiService AlertRulesApi service
type AlertRulesApiService service

type ApiV1InstancesAlertgroupsAlertrulesAllDeleteRequest struct {
	ctx           context.Context
	ApiService    *AlertRulesApiService
	groupName     string
	instanceId    string
	authorization *string
	alertName     *[]string
}

// Accepts basic auth and bearer token from admins and jwt token from oauth and basic auth from api user
func (r ApiV1InstancesAlertgroupsAlertrulesAllDeleteRequest) Authorization(authorization string) ApiV1InstancesAlertgroupsAlertrulesAllDeleteRequest {
	r.authorization = &authorization
	return r
}

// Name of the alert rules that should be deleted
func (r ApiV1InstancesAlertgroupsAlertrulesAllDeleteRequest) AlertName(alertName []string) ApiV1InstancesAlertgroupsAlertrulesAllDeleteRequest {
	r.alertName = &alertName
	return r
}

func (r ApiV1InstancesAlertgroupsAlertrulesAllDeleteRequest) Execute() (*PostAlertRule, *http.Response, error) {
	return r.ApiService.V1InstancesAlertgroupsAlertrulesAllDeleteExecute(r)
}

/*
V1InstancesAlertgroupsAlertrulesAllDelete Method for V1InstancesAlertgroupsAlertrulesAllDelete

delete alert rules

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupName
	@param instanceId
	@return ApiV1InstancesAlertgroupsAlertrulesAllDeleteRequest
*/
func (a *AlertRulesApiService) V1InstancesAlertgroupsAlertrulesAllDelete(ctx context.Context, groupName string, instanceId string) ApiV1InstancesAlertgroupsAlertrulesAllDeleteRequest {
	return ApiV1InstancesAlertgroupsAlertrulesAllDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		groupName:  groupName,
		instanceId: instanceId,
	}
}

// Execute executes the request
//
//	@return PostAlertRule
func (a *AlertRulesApiService) V1InstancesAlertgroupsAlertrulesAllDeleteExecute(r ApiV1InstancesAlertgroupsAlertrulesAllDeleteRequest) (*PostAlertRule, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PostAlertRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRulesApiService.V1InstancesAlertgroupsAlertrulesAllDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertgroups/{groupName}/alertrules"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.alertName == nil {
		return localVarReturnValue, nil, reportError("alertName is required and must be specified")
	}

	{
		t := *r.alertName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("alertName", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("alertName", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesAlertgroupsAlertrulesCreateRequest struct {
	ctx                                           context.Context
	ApiService                                    *AlertRulesApiService
	groupName                                     string
	instanceId                                    string
	authorization                                 *string
	v1InstancesAlertgroupsAlertrulesCreateRequest *V1InstancesAlertgroupsAlertrulesCreateRequest
}

// Accepts basic auth and bearer token from admins and jwt token from oauth and basic auth from api user
func (r ApiV1InstancesAlertgroupsAlertrulesCreateRequest) Authorization(authorization string) ApiV1InstancesAlertgroupsAlertrulesCreateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertgroupsAlertrulesCreateRequest) V1InstancesAlertgroupsAlertrulesCreateRequest(v1InstancesAlertgroupsAlertrulesCreateRequest V1InstancesAlertgroupsAlertrulesCreateRequest) ApiV1InstancesAlertgroupsAlertrulesCreateRequest {
	r.v1InstancesAlertgroupsAlertrulesCreateRequest = &v1InstancesAlertgroupsAlertrulesCreateRequest
	return r
}

func (r ApiV1InstancesAlertgroupsAlertrulesCreateRequest) Execute() (*PostAlertRule, *http.Response, error) {
	return r.ApiService.V1InstancesAlertgroupsAlertrulesCreateExecute(r)
}

/*
V1InstancesAlertgroupsAlertrulesCreate Method for V1InstancesAlertgroupsAlertrulesCreate

create alert rule config

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupName
	@param instanceId
	@return ApiV1InstancesAlertgroupsAlertrulesCreateRequest
*/
func (a *AlertRulesApiService) V1InstancesAlertgroupsAlertrulesCreate(ctx context.Context, groupName string, instanceId string) ApiV1InstancesAlertgroupsAlertrulesCreateRequest {
	return ApiV1InstancesAlertgroupsAlertrulesCreateRequest{
		ApiService: a,
		ctx:        ctx,
		groupName:  groupName,
		instanceId: instanceId,
	}
}

// Execute executes the request
//
//	@return PostAlertRule
func (a *AlertRulesApiService) V1InstancesAlertgroupsAlertrulesCreateExecute(r ApiV1InstancesAlertgroupsAlertrulesCreateRequest) (*PostAlertRule, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PostAlertRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRulesApiService.V1InstancesAlertgroupsAlertrulesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertgroups/{groupName}/alertrules"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1InstancesAlertgroupsAlertrulesCreateRequest == nil {
		return localVarReturnValue, nil, reportError("v1InstancesAlertgroupsAlertrulesCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.v1InstancesAlertgroupsAlertrulesCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesAlertgroupsAlertrulesDeleteRequest struct {
	ctx           context.Context
	ApiService    *AlertRulesApiService
	alertName     string
	groupName     string
	instanceId    string
	authorization *string
}

// Accepts basic auth and bearer token from admins and jwt token from oauth and basic auth from api user
func (r ApiV1InstancesAlertgroupsAlertrulesDeleteRequest) Authorization(authorization string) ApiV1InstancesAlertgroupsAlertrulesDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertgroupsAlertrulesDeleteRequest) Execute() (*DeleteAlertRule, *http.Response, error) {
	return r.ApiService.V1InstancesAlertgroupsAlertrulesDeleteExecute(r)
}

/*
V1InstancesAlertgroupsAlertrulesDelete Method for V1InstancesAlertgroupsAlertrulesDelete

delete alert rule config

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param alertName
	@param groupName
	@param instanceId
	@return ApiV1InstancesAlertgroupsAlertrulesDeleteRequest
*/
func (a *AlertRulesApiService) V1InstancesAlertgroupsAlertrulesDelete(ctx context.Context, alertName string, groupName string, instanceId string) ApiV1InstancesAlertgroupsAlertrulesDeleteRequest {
	return ApiV1InstancesAlertgroupsAlertrulesDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		alertName:  alertName,
		groupName:  groupName,
		instanceId: instanceId,
	}
}

// Execute executes the request
//
//	@return DeleteAlertRule
func (a *AlertRulesApiService) V1InstancesAlertgroupsAlertrulesDeleteExecute(r ApiV1InstancesAlertgroupsAlertrulesDeleteRequest) (*DeleteAlertRule, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeleteAlertRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRulesApiService.V1InstancesAlertgroupsAlertrulesDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertgroups/{groupName}/alertrules/{alertName}"
	localVarPath = strings.Replace(localVarPath, "{"+"alertName"+"}", url.PathEscape(parameterToString(r.alertName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesAlertgroupsAlertrulesListRequest struct {
	ctx           context.Context
	ApiService    *AlertRulesApiService
	groupName     string
	instanceId    string
	authorization *string
}

// Accepts basic auth and bearer token from admins and jwt token from oauth and basic auth from api user
func (r ApiV1InstancesAlertgroupsAlertrulesListRequest) Authorization(authorization string) ApiV1InstancesAlertgroupsAlertrulesListRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertgroupsAlertrulesListRequest) Execute() (*GetAllAlertRules, *http.Response, error) {
	return r.ApiService.V1InstancesAlertgroupsAlertrulesListExecute(r)
}

/*
V1InstancesAlertgroupsAlertrulesList Method for V1InstancesAlertgroupsAlertrulesList

get alert rule config

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupName
	@param instanceId
	@return ApiV1InstancesAlertgroupsAlertrulesListRequest
*/
func (a *AlertRulesApiService) V1InstancesAlertgroupsAlertrulesList(ctx context.Context, groupName string, instanceId string) ApiV1InstancesAlertgroupsAlertrulesListRequest {
	return ApiV1InstancesAlertgroupsAlertrulesListRequest{
		ApiService: a,
		ctx:        ctx,
		groupName:  groupName,
		instanceId: instanceId,
	}
}

// Execute executes the request
//
//	@return GetAllAlertRules
func (a *AlertRulesApiService) V1InstancesAlertgroupsAlertrulesListExecute(r ApiV1InstancesAlertgroupsAlertrulesListRequest) (*GetAllAlertRules, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetAllAlertRules
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRulesApiService.V1InstancesAlertgroupsAlertrulesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertgroups/{groupName}/alertrules"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesAlertgroupsAlertrulesPartialUpdateRequest struct {
	ctx                                           context.Context
	ApiService                                    *AlertRulesApiService
	groupName                                     string
	instanceId                                    string
	authorization                                 *string
	v1InstancesAlertgroupsAlertrulesCreateRequest *[]V1InstancesAlertgroupsAlertrulesCreateRequest
}

// Accepts basic auth and bearer token from admins and jwt token from oauth and basic auth from api user
func (r ApiV1InstancesAlertgroupsAlertrulesPartialUpdateRequest) Authorization(authorization string) ApiV1InstancesAlertgroupsAlertrulesPartialUpdateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertgroupsAlertrulesPartialUpdateRequest) V1InstancesAlertgroupsAlertrulesCreateRequest(v1InstancesAlertgroupsAlertrulesCreateRequest []V1InstancesAlertgroupsAlertrulesCreateRequest) ApiV1InstancesAlertgroupsAlertrulesPartialUpdateRequest {
	r.v1InstancesAlertgroupsAlertrulesCreateRequest = &v1InstancesAlertgroupsAlertrulesCreateRequest
	return r
}

func (r ApiV1InstancesAlertgroupsAlertrulesPartialUpdateRequest) Execute() (*PostAlertRule, *http.Response, error) {
	return r.ApiService.V1InstancesAlertgroupsAlertrulesPartialUpdateExecute(r)
}

/*
V1InstancesAlertgroupsAlertrulesPartialUpdate Method for V1InstancesAlertgroupsAlertrulesPartialUpdate

patches alert rules

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupName
	@param instanceId
	@return ApiV1InstancesAlertgroupsAlertrulesPartialUpdateRequest
*/
func (a *AlertRulesApiService) V1InstancesAlertgroupsAlertrulesPartialUpdate(ctx context.Context, groupName string, instanceId string) ApiV1InstancesAlertgroupsAlertrulesPartialUpdateRequest {
	return ApiV1InstancesAlertgroupsAlertrulesPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		groupName:  groupName,
		instanceId: instanceId,
	}
}

// Execute executes the request
//
//	@return PostAlertRule
func (a *AlertRulesApiService) V1InstancesAlertgroupsAlertrulesPartialUpdateExecute(r ApiV1InstancesAlertgroupsAlertrulesPartialUpdateRequest) (*PostAlertRule, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PostAlertRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRulesApiService.V1InstancesAlertgroupsAlertrulesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertgroups/{groupName}/alertrules"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1InstancesAlertgroupsAlertrulesCreateRequest == nil {
		return localVarReturnValue, nil, reportError("v1InstancesAlertgroupsAlertrulesCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.v1InstancesAlertgroupsAlertrulesCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesAlertgroupsAlertrulesReadRequest struct {
	ctx           context.Context
	ApiService    *AlertRulesApiService
	alertName     string
	groupName     string
	instanceId    string
	authorization *string
}

// Accepts basic auth and bearer token from admins and jwt token from oauth and basic auth from api user
func (r ApiV1InstancesAlertgroupsAlertrulesReadRequest) Authorization(authorization string) ApiV1InstancesAlertgroupsAlertrulesReadRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertgroupsAlertrulesReadRequest) Execute() (*GetAlertRule, *http.Response, error) {
	return r.ApiService.V1InstancesAlertgroupsAlertrulesReadExecute(r)
}

/*
V1InstancesAlertgroupsAlertrulesRead Method for V1InstancesAlertgroupsAlertrulesRead

get alert rule config

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param alertName
	@param groupName
	@param instanceId
	@return ApiV1InstancesAlertgroupsAlertrulesReadRequest
*/
func (a *AlertRulesApiService) V1InstancesAlertgroupsAlertrulesRead(ctx context.Context, alertName string, groupName string, instanceId string) ApiV1InstancesAlertgroupsAlertrulesReadRequest {
	return ApiV1InstancesAlertgroupsAlertrulesReadRequest{
		ApiService: a,
		ctx:        ctx,
		alertName:  alertName,
		groupName:  groupName,
		instanceId: instanceId,
	}
}

// Execute executes the request
//
//	@return GetAlertRule
func (a *AlertRulesApiService) V1InstancesAlertgroupsAlertrulesReadExecute(r ApiV1InstancesAlertgroupsAlertrulesReadRequest) (*GetAlertRule, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetAlertRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRulesApiService.V1InstancesAlertgroupsAlertrulesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertgroups/{groupName}/alertrules/{alertName}"
	localVarPath = strings.Replace(localVarPath, "{"+"alertName"+"}", url.PathEscape(parameterToString(r.alertName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1InstancesAlertgroupsAlertrulesUpdateRequest struct {
	ctx                                           context.Context
	ApiService                                    *AlertRulesApiService
	alertName                                     string
	groupName                                     string
	instanceId                                    string
	authorization                                 *string
	v1InstancesAlertgroupsAlertrulesCreateRequest *V1InstancesAlertgroupsAlertrulesCreateRequest
}

// Accepts basic auth and bearer token from admins and jwt token from oauth and basic auth from api user
func (r ApiV1InstancesAlertgroupsAlertrulesUpdateRequest) Authorization(authorization string) ApiV1InstancesAlertgroupsAlertrulesUpdateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InstancesAlertgroupsAlertrulesUpdateRequest) V1InstancesAlertgroupsAlertrulesCreateRequest(v1InstancesAlertgroupsAlertrulesCreateRequest V1InstancesAlertgroupsAlertrulesCreateRequest) ApiV1InstancesAlertgroupsAlertrulesUpdateRequest {
	r.v1InstancesAlertgroupsAlertrulesCreateRequest = &v1InstancesAlertgroupsAlertrulesCreateRequest
	return r
}

func (r ApiV1InstancesAlertgroupsAlertrulesUpdateRequest) Execute() (*PutAlertRule, *http.Response, error) {
	return r.ApiService.V1InstancesAlertgroupsAlertrulesUpdateExecute(r)
}

/*
V1InstancesAlertgroupsAlertrulesUpdate Method for V1InstancesAlertgroupsAlertrulesUpdate

update alert rule config

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param alertName
	@param groupName
	@param instanceId
	@return ApiV1InstancesAlertgroupsAlertrulesUpdateRequest
*/
func (a *AlertRulesApiService) V1InstancesAlertgroupsAlertrulesUpdate(ctx context.Context, alertName string, groupName string, instanceId string) ApiV1InstancesAlertgroupsAlertrulesUpdateRequest {
	return ApiV1InstancesAlertgroupsAlertrulesUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		alertName:  alertName,
		groupName:  groupName,
		instanceId: instanceId,
	}
}

// Execute executes the request
//
//	@return PutAlertRule
func (a *AlertRulesApiService) V1InstancesAlertgroupsAlertrulesUpdateExecute(r ApiV1InstancesAlertgroupsAlertrulesUpdateRequest) (*PutAlertRule, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PutAlertRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRulesApiService.V1InstancesAlertgroupsAlertrulesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/instances/{instanceId}/alertgroups/{groupName}/alertrules/{alertName}"
	localVarPath = strings.Replace(localVarPath, "{"+"alertName"+"}", url.PathEscape(parameterToString(r.alertName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1InstancesAlertgroupsAlertrulesCreateRequest == nil {
		return localVarReturnValue, nil, reportError("v1InstancesAlertgroupsAlertrulesCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.v1InstancesAlertgroupsAlertrulesCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertgroupsAlertrulesAllDeleteRequest struct {
	ctx           context.Context
	ApiService    *AlertRulesApiService
	groupName     string
	instanceId    string
	projectId     string
	authorization *string
	alertName     *[]string
}

// Accepts basic auth and bearer token from admins and jwt token from oauth and basic auth from api user
func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesAllDeleteRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertgroupsAlertrulesAllDeleteRequest {
	r.authorization = &authorization
	return r
}

// Name of the alert rules that should be deleted
func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesAllDeleteRequest) AlertName(alertName []string) ApiV1ProjectsInstancesAlertgroupsAlertrulesAllDeleteRequest {
	r.alertName = &alertName
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesAllDeleteRequest) Execute() (*PostAlertRule, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertgroupsAlertrulesAllDeleteExecute(r)
}

/*
V1ProjectsInstancesAlertgroupsAlertrulesAllDelete Method for V1ProjectsInstancesAlertgroupsAlertrulesAllDelete

delete alert rules

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupName
	@param instanceId
	@param projectId
	@return ApiV1ProjectsInstancesAlertgroupsAlertrulesAllDeleteRequest
*/
func (a *AlertRulesApiService) V1ProjectsInstancesAlertgroupsAlertrulesAllDelete(ctx context.Context, groupName string, instanceId string, projectId string) ApiV1ProjectsInstancesAlertgroupsAlertrulesAllDeleteRequest {
	return ApiV1ProjectsInstancesAlertgroupsAlertrulesAllDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		groupName:  groupName,
		instanceId: instanceId,
		projectId:  projectId,
	}
}

// Execute executes the request
//
//	@return PostAlertRule
func (a *AlertRulesApiService) V1ProjectsInstancesAlertgroupsAlertrulesAllDeleteExecute(r ApiV1ProjectsInstancesAlertgroupsAlertrulesAllDeleteRequest) (*PostAlertRule, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PostAlertRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRulesApiService.V1ProjectsInstancesAlertgroupsAlertrulesAllDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertgroups/{groupName}/alertrules"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.alertName == nil {
		return localVarReturnValue, nil, reportError("alertName is required and must be specified")
	}

	{
		t := *r.alertName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("alertName", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("alertName", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertgroupsAlertrulesCreateRequest struct {
	ctx                                           context.Context
	ApiService                                    *AlertRulesApiService
	groupName                                     string
	instanceId                                    string
	projectId                                     string
	authorization                                 *string
	v1InstancesAlertgroupsAlertrulesCreateRequest *V1InstancesAlertgroupsAlertrulesCreateRequest
}

// Accepts basic auth and bearer token from admins and jwt token from oauth and basic auth from api user
func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesCreateRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertgroupsAlertrulesCreateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesCreateRequest) V1InstancesAlertgroupsAlertrulesCreateRequest(v1InstancesAlertgroupsAlertrulesCreateRequest V1InstancesAlertgroupsAlertrulesCreateRequest) ApiV1ProjectsInstancesAlertgroupsAlertrulesCreateRequest {
	r.v1InstancesAlertgroupsAlertrulesCreateRequest = &v1InstancesAlertgroupsAlertrulesCreateRequest
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesCreateRequest) Execute() (*PostAlertRule, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertgroupsAlertrulesCreateExecute(r)
}

/*
V1ProjectsInstancesAlertgroupsAlertrulesCreate Method for V1ProjectsInstancesAlertgroupsAlertrulesCreate

create alert rule config

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupName
	@param instanceId
	@param projectId
	@return ApiV1ProjectsInstancesAlertgroupsAlertrulesCreateRequest
*/
func (a *AlertRulesApiService) V1ProjectsInstancesAlertgroupsAlertrulesCreate(ctx context.Context, groupName string, instanceId string, projectId string) ApiV1ProjectsInstancesAlertgroupsAlertrulesCreateRequest {
	return ApiV1ProjectsInstancesAlertgroupsAlertrulesCreateRequest{
		ApiService: a,
		ctx:        ctx,
		groupName:  groupName,
		instanceId: instanceId,
		projectId:  projectId,
	}
}

// Execute executes the request
//
//	@return PostAlertRule
func (a *AlertRulesApiService) V1ProjectsInstancesAlertgroupsAlertrulesCreateExecute(r ApiV1ProjectsInstancesAlertgroupsAlertrulesCreateRequest) (*PostAlertRule, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PostAlertRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRulesApiService.V1ProjectsInstancesAlertgroupsAlertrulesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertgroups/{groupName}/alertrules"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1InstancesAlertgroupsAlertrulesCreateRequest == nil {
		return localVarReturnValue, nil, reportError("v1InstancesAlertgroupsAlertrulesCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.v1InstancesAlertgroupsAlertrulesCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertgroupsAlertrulesDeleteRequest struct {
	ctx           context.Context
	ApiService    *AlertRulesApiService
	alertName     string
	groupName     string
	instanceId    string
	projectId     string
	authorization *string
}

// Accepts basic auth and bearer token from admins and jwt token from oauth and basic auth from api user
func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesDeleteRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertgroupsAlertrulesDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesDeleteRequest) Execute() (*DeleteAlertRule, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertgroupsAlertrulesDeleteExecute(r)
}

/*
V1ProjectsInstancesAlertgroupsAlertrulesDelete Method for V1ProjectsInstancesAlertgroupsAlertrulesDelete

delete alert rule config

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param alertName
	@param groupName
	@param instanceId
	@param projectId
	@return ApiV1ProjectsInstancesAlertgroupsAlertrulesDeleteRequest
*/
func (a *AlertRulesApiService) V1ProjectsInstancesAlertgroupsAlertrulesDelete(ctx context.Context, alertName string, groupName string, instanceId string, projectId string) ApiV1ProjectsInstancesAlertgroupsAlertrulesDeleteRequest {
	return ApiV1ProjectsInstancesAlertgroupsAlertrulesDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		alertName:  alertName,
		groupName:  groupName,
		instanceId: instanceId,
		projectId:  projectId,
	}
}

// Execute executes the request
//
//	@return DeleteAlertRule
func (a *AlertRulesApiService) V1ProjectsInstancesAlertgroupsAlertrulesDeleteExecute(r ApiV1ProjectsInstancesAlertgroupsAlertrulesDeleteRequest) (*DeleteAlertRule, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeleteAlertRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRulesApiService.V1ProjectsInstancesAlertgroupsAlertrulesDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertgroups/{groupName}/alertrules/{alertName}"
	localVarPath = strings.Replace(localVarPath, "{"+"alertName"+"}", url.PathEscape(parameterToString(r.alertName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertgroupsAlertrulesListRequest struct {
	ctx           context.Context
	ApiService    *AlertRulesApiService
	groupName     string
	instanceId    string
	projectId     string
	authorization *string
}

// Accepts basic auth and bearer token from admins and jwt token from oauth and basic auth from api user
func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesListRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertgroupsAlertrulesListRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesListRequest) Execute() (*GetAllAlertRules, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertgroupsAlertrulesListExecute(r)
}

/*
V1ProjectsInstancesAlertgroupsAlertrulesList Method for V1ProjectsInstancesAlertgroupsAlertrulesList

get alert rule config

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupName
	@param instanceId
	@param projectId
	@return ApiV1ProjectsInstancesAlertgroupsAlertrulesListRequest
*/
func (a *AlertRulesApiService) V1ProjectsInstancesAlertgroupsAlertrulesList(ctx context.Context, groupName string, instanceId string, projectId string) ApiV1ProjectsInstancesAlertgroupsAlertrulesListRequest {
	return ApiV1ProjectsInstancesAlertgroupsAlertrulesListRequest{
		ApiService: a,
		ctx:        ctx,
		groupName:  groupName,
		instanceId: instanceId,
		projectId:  projectId,
	}
}

// Execute executes the request
//
//	@return GetAllAlertRules
func (a *AlertRulesApiService) V1ProjectsInstancesAlertgroupsAlertrulesListExecute(r ApiV1ProjectsInstancesAlertgroupsAlertrulesListRequest) (*GetAllAlertRules, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetAllAlertRules
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRulesApiService.V1ProjectsInstancesAlertgroupsAlertrulesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertgroups/{groupName}/alertrules"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertgroupsAlertrulesPartialUpdateRequest struct {
	ctx                                           context.Context
	ApiService                                    *AlertRulesApiService
	groupName                                     string
	instanceId                                    string
	projectId                                     string
	authorization                                 *string
	v1InstancesAlertgroupsAlertrulesCreateRequest *[]V1InstancesAlertgroupsAlertrulesCreateRequest
}

// Accepts basic auth and bearer token from admins and jwt token from oauth and basic auth from api user
func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesPartialUpdateRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertgroupsAlertrulesPartialUpdateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesPartialUpdateRequest) V1InstancesAlertgroupsAlertrulesCreateRequest(v1InstancesAlertgroupsAlertrulesCreateRequest []V1InstancesAlertgroupsAlertrulesCreateRequest) ApiV1ProjectsInstancesAlertgroupsAlertrulesPartialUpdateRequest {
	r.v1InstancesAlertgroupsAlertrulesCreateRequest = &v1InstancesAlertgroupsAlertrulesCreateRequest
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesPartialUpdateRequest) Execute() (*PostAlertRule, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertgroupsAlertrulesPartialUpdateExecute(r)
}

/*
V1ProjectsInstancesAlertgroupsAlertrulesPartialUpdate Method for V1ProjectsInstancesAlertgroupsAlertrulesPartialUpdate

patches alert rules

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupName
	@param instanceId
	@param projectId
	@return ApiV1ProjectsInstancesAlertgroupsAlertrulesPartialUpdateRequest
*/
func (a *AlertRulesApiService) V1ProjectsInstancesAlertgroupsAlertrulesPartialUpdate(ctx context.Context, groupName string, instanceId string, projectId string) ApiV1ProjectsInstancesAlertgroupsAlertrulesPartialUpdateRequest {
	return ApiV1ProjectsInstancesAlertgroupsAlertrulesPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		groupName:  groupName,
		instanceId: instanceId,
		projectId:  projectId,
	}
}

// Execute executes the request
//
//	@return PostAlertRule
func (a *AlertRulesApiService) V1ProjectsInstancesAlertgroupsAlertrulesPartialUpdateExecute(r ApiV1ProjectsInstancesAlertgroupsAlertrulesPartialUpdateRequest) (*PostAlertRule, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PostAlertRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRulesApiService.V1ProjectsInstancesAlertgroupsAlertrulesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertgroups/{groupName}/alertrules"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1InstancesAlertgroupsAlertrulesCreateRequest == nil {
		return localVarReturnValue, nil, reportError("v1InstancesAlertgroupsAlertrulesCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.v1InstancesAlertgroupsAlertrulesCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertgroupsAlertrulesReadRequest struct {
	ctx           context.Context
	ApiService    *AlertRulesApiService
	alertName     string
	groupName     string
	instanceId    string
	projectId     string
	authorization *string
}

// Accepts basic auth and bearer token from admins and jwt token from oauth and basic auth from api user
func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesReadRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertgroupsAlertrulesReadRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesReadRequest) Execute() (*GetAlertRule, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertgroupsAlertrulesReadExecute(r)
}

/*
V1ProjectsInstancesAlertgroupsAlertrulesRead Method for V1ProjectsInstancesAlertgroupsAlertrulesRead

get alert rule config

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param alertName
	@param groupName
	@param instanceId
	@param projectId
	@return ApiV1ProjectsInstancesAlertgroupsAlertrulesReadRequest
*/
func (a *AlertRulesApiService) V1ProjectsInstancesAlertgroupsAlertrulesRead(ctx context.Context, alertName string, groupName string, instanceId string, projectId string) ApiV1ProjectsInstancesAlertgroupsAlertrulesReadRequest {
	return ApiV1ProjectsInstancesAlertgroupsAlertrulesReadRequest{
		ApiService: a,
		ctx:        ctx,
		alertName:  alertName,
		groupName:  groupName,
		instanceId: instanceId,
		projectId:  projectId,
	}
}

// Execute executes the request
//
//	@return GetAlertRule
func (a *AlertRulesApiService) V1ProjectsInstancesAlertgroupsAlertrulesReadExecute(r ApiV1ProjectsInstancesAlertgroupsAlertrulesReadRequest) (*GetAlertRule, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetAlertRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRulesApiService.V1ProjectsInstancesAlertgroupsAlertrulesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertgroups/{groupName}/alertrules/{alertName}"
	localVarPath = strings.Replace(localVarPath, "{"+"alertName"+"}", url.PathEscape(parameterToString(r.alertName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ProjectsInstancesAlertgroupsAlertrulesUpdateRequest struct {
	ctx                                           context.Context
	ApiService                                    *AlertRulesApiService
	alertName                                     string
	groupName                                     string
	instanceId                                    string
	projectId                                     string
	authorization                                 *string
	v1InstancesAlertgroupsAlertrulesCreateRequest *V1InstancesAlertgroupsAlertrulesCreateRequest
}

// Accepts basic auth and bearer token from admins and jwt token from oauth and basic auth from api user
func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesUpdateRequest) Authorization(authorization string) ApiV1ProjectsInstancesAlertgroupsAlertrulesUpdateRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesUpdateRequest) V1InstancesAlertgroupsAlertrulesCreateRequest(v1InstancesAlertgroupsAlertrulesCreateRequest V1InstancesAlertgroupsAlertrulesCreateRequest) ApiV1ProjectsInstancesAlertgroupsAlertrulesUpdateRequest {
	r.v1InstancesAlertgroupsAlertrulesCreateRequest = &v1InstancesAlertgroupsAlertrulesCreateRequest
	return r
}

func (r ApiV1ProjectsInstancesAlertgroupsAlertrulesUpdateRequest) Execute() (*PutAlertRule, *http.Response, error) {
	return r.ApiService.V1ProjectsInstancesAlertgroupsAlertrulesUpdateExecute(r)
}

/*
V1ProjectsInstancesAlertgroupsAlertrulesUpdate Method for V1ProjectsInstancesAlertgroupsAlertrulesUpdate

update alert rule config

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param alertName
	@param groupName
	@param instanceId
	@param projectId
	@return ApiV1ProjectsInstancesAlertgroupsAlertrulesUpdateRequest
*/
func (a *AlertRulesApiService) V1ProjectsInstancesAlertgroupsAlertrulesUpdate(ctx context.Context, alertName string, groupName string, instanceId string, projectId string) ApiV1ProjectsInstancesAlertgroupsAlertrulesUpdateRequest {
	return ApiV1ProjectsInstancesAlertgroupsAlertrulesUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		alertName:  alertName,
		groupName:  groupName,
		instanceId: instanceId,
		projectId:  projectId,
	}
}

// Execute executes the request
//
//	@return PutAlertRule
func (a *AlertRulesApiService) V1ProjectsInstancesAlertgroupsAlertrulesUpdateExecute(r ApiV1ProjectsInstancesAlertgroupsAlertrulesUpdateRequest) (*PutAlertRule, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PutAlertRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertRulesApiService.V1ProjectsInstancesAlertgroupsAlertrulesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/instances/{instanceId}/alertgroups/{groupName}/alertrules/{alertName}"
	localVarPath = strings.Replace(localVarPath, "{"+"alertName"+"}", url.PathEscape(parameterToString(r.alertName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1InstancesAlertgroupsAlertrulesCreateRequest == nil {
		return localVarReturnValue, nil, reportError("v1InstancesAlertgroupsAlertrulesCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.v1InstancesAlertgroupsAlertrulesCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PermissionDenied
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
